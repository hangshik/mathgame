<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Îß§ÏßÅ ÌïÑ(Magic Fill)</title>
    <style>
        :root {
            --board-rows: 5;
            --board-cols: 5;
            
            --color-bg: #f8f9fa;
            --color-cell-empty: #ffffff;
            --color-shape: #4dabf7;
            --color-shape-fixed: #339af0;
            --color-shape-border: #1864ab;
            --color-preview: rgba(77, 171, 247, 0.4);
            --color-error: #ff8787;
            --color-active: #228be6;
            --color-count-text: #868e96;
            --color-count-correct: #40c057; 
            --color-count-excess: #fa5252; 
            --cell-size: 40px; 
        }

        body {
            font-family: 'Pretendard', 'Segoe UI', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            background-color: var(--color-bg);
            margin: 0;
            padding: 20px 10px;
            color: #333;
            min-height: 100vh;
            touch-action: pan-y; 
            user-select: none;
            -webkit-user-select: none;
            font-size: 16px; 
        }

        h1 { margin: 0 0 20px 0; font-size: 32px; color: #343a40; font-weight: 800; }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            max-width: 500px;
        }

        .level-panel {
            background: white; padding: 15px; border-radius: 16px;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05); margin-bottom: 20px;
            width: 100%; box-sizing: border-box;
        }
        .level-buttons { display: grid; grid-template-columns: repeat(5, 1fr); gap: 6px; }
        .level-btn {
            padding: 10px 0; background-color: #fff; color: #555;
            border: 1px solid #dee2e6; border-radius: 10px; cursor: pointer;
            font-weight: 700; font-size: 15px; display: flex;
            flex-direction: column; align-items: center; justify-content: center;
            transition: all 0.2s; min-height: 50px;
        }
        .level-btn:hover { background-color: #f1f3f5; }
        .level-btn.active {
            background-color: var(--color-active); color: white;
            border-color: var(--color-active);
            box-shadow: 0 4px 10px rgba(34,139,230,0.3); transform: translateY(-2px);
        }
        .level-btn.cleared { background-color: #40c057; border-color: #2f9e44; color: white; }
        .lvl-record { font-size: 11px; font-weight: normal; margin-top: 2px; opacity: 0.9; }

        .game-info-bar {
            display: flex; justify-content: space-between; align-items: center;
            width: 100%; margin-bottom: 20px; background: white;
            padding: 15px 20px; border-radius: 14px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.03); box-sizing: border-box;
        }
        .info-left { display: flex; flex-direction: column; width: 30%; }
        .info-title { font-weight: 800; font-size: 20px; margin-bottom: 4px; color: #333; }
        .info-sub { font-size: 15px; color: #666; font-weight: 600; }
        .info-center {
            display: flex; justify-content: center; align-items: center;
            width: 40%; font-size: 28px; font-weight: 800; color: var(--color-active);
        }
        .info-center.full { color: #2b8a3e; }
        .info-right { display: flex; justify-content: flex-end; width: 30%; }
        .timer { font-size: 24px; font-family: 'Courier New', monospace; font-weight: 800; color: #333; }

        .game-board-wrapper {
            margin-bottom: 20px; width: 100%;
            display: grid;
            grid-template-columns: 1fr 30px; 
            grid-template-rows: auto 30px;
            gap: 5px; justify-items: center; align-items: center;
        }

        .game-board {
            grid-column: 1 / 2; grid-row: 1 / 2;
            display: grid; 
            grid-template-columns: repeat(var(--board-cols), 1fr);
            grid-template-rows: repeat(var(--board-rows), 1fr);
            border: 2px solid #adb5bd; background-color: #adb5bd; 
            gap: 1px; box-shadow: 0 8px 30px rgba(0,0,0,0.08);
            width: 100%; touch-action: none; 
        }

        .counts-col {
            grid-column: 1 / 2; grid-row: 2 / 3;
            width: 100%; height: 100%; display: grid;
            grid-template-columns: repeat(var(--board-cols), 1fr); gap: 1px;
        }
        .counts-row {
            grid-column: 2 / 3; grid-row: 1 / 2;
            height: 100%; width: 100%; display: grid;
            grid-template-rows: repeat(var(--board-rows), 1fr); gap: 1px;
        }
        
        .count-cell {
            display: flex; align-items: center; justify-content: center;
            font-size: min(24px, calc(var(--cell-size) * 0.5)); 
            font-weight: 700;
            color: var(--color-count-text);
            opacity: 0; transition: opacity 0.2s, color 0.2s, font-size 0.2s;
            overflow: hidden; 
        }
        .count-cell.visible { opacity: 1; }
        .count-cell.correct { color: var(--color-count-correct); font-weight: 800; }
        .count-cell.excess { color: var(--color-count-excess); font-weight: 900; }

        .cell {
            background-color: var(--color-cell-empty); position: relative;
            box-sizing: border-box; aspect-ratio: 1; 
            border: 0px solid var(--color-shape-border);
        }
        .cell.b-top { border-top-width: 2px; }
        .cell.b-bottom { border-bottom-width: 2px; }
        .cell.b-left { border-left-width: 2px; }
        .cell.b-right { border-right-width: 2px; }

        .cell.shape { background-color: var(--color-shape); }
        .cell.fixed { background-color: var(--color-shape-fixed); }
        .cell.fixed::after {
            content: 'üîí'; position: absolute; font-size: 14px;
            top: 50%; left: 50%; transform: translate(-50%, -50%); opacity: 0.6;
        }
        .cell.error { background-color: var(--color-error) !important; border-color: #c92a2a !important; }
        
        .cell.preview-valid { background-color: var(--color-preview); box-shadow: inset 0 0 0 3px var(--color-active); }
        .cell.preview-invalid { background-color: rgba(255, 135, 135, 0.4); box-shadow: inset 0 0 0 3px var(--color-error); }

        .palette-area {
            width: 100%; background: white; border-radius: 16px; padding: 15px;
            min-height: 110px; display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            box-shadow: 0 -4px 15px rgba(0,0,0,0.03); margin-bottom: 15px; box-sizing: border-box;
        }
        .palette-label { font-size: 17px; color: #555; margin-bottom: 12px; font-weight: bold; }
        
        .palette-shape-container {
            display: flex; justify-content: center; align-items: center;
            width: 80px; height: 80px; cursor: pointer;
            transition: transform 0.1s; padding: 5px; border-radius: 8px;
            touch-action: none; 
        }
        .palette-shape-container:active { transform: scale(0.95); background-color: #f1f3f5; }

        .ghost-shape {
            position: fixed; pointer-events: none; z-index: 9999;
            opacity: 0.8; display: grid; gap: 1px;
            transform: translate(-50%, -50%);
            filter: drop-shadow(0 5px 15px rgba(0,0,0,0.3));
        }
        .ghost-cell {
            width: 100%; height: 100%; background-color: var(--color-shape);
            box-sizing: border-box; border: 0px solid var(--color-shape-border);
        }
        .ghost-cell.b-top { border-top-width: 2px; }
        .ghost-cell.b-bottom { border-bottom-width: 2px; }
        .ghost-cell.b-left { border-left-width: 2px; }
        .ghost-cell.b-right { border-right-width: 2px; }

        .mini-grid { display: grid; gap: 2px; }
        .mini-cell { width: 22px; height: 22px; background-color: transparent; }
        .mini-cell.filled { background-color: var(--color-shape); border-radius: 3px; }

        .msg-area {
            width: 100%; padding: 12px; margin-bottom: 10px;
            border-radius: 8px; text-align: center; font-weight: bold; font-size: 15px;
            box-sizing: border-box; display: none; animation: fadeIn 0.2s;
        }
        .msg-error { background-color: #ffebee; color: #d32f2f; border: 1px solid #ffcdd2; }
        .msg-info { background-color: #e3f2fd; color: #1976d2; border: 1px solid #bbdefb; }

        .controls {
            display: flex; align-items: center; gap: 10px; 
            width: 100%; margin-bottom: 30px;
        }
        .chk-wrapper {
            display: flex; align-items: center; background: white;
            padding: 0 15px; height: 52px; border-radius: 12px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05); font-weight: 600;
            color: #555; cursor: pointer; user-select: none;
            white-space: nowrap;
        }
        .chk-wrapper input {
            width: 18px; height: 18px; margin-right: 8px; cursor: pointer;
            accent-color: var(--color-active);
        }
        .btn-ctrl {
            flex: 1; padding: 15px 5px; border-radius: 12px;
            cursor: pointer; font-weight: 700; font-size: 16px;
            border: none; color: white;
            white-space: nowrap;
        }
        .btn-reset { background-color: #868e96; }
        
        .btn-hint { background-color: #fab005; color: white; display: flex; align-items: center; justify-content: center; }
        .btn-hint:active { background-color: #f08c00; }
        .btn-hint svg { margin-right: 5px; fill: white; width: 16px; height: 16px; }

        .rules {
            font-size: 15px; line-height: 1.6; color: #495057;
            background: white; padding: 20px; border-radius: 16px;
            width: 100%; box-sizing: border-box; margin-bottom: 40px;
        }
        .rules b { color: #212529; font-size: 16px; }
        .highlight { color: #228be6; font-weight: bold; }

        .modal-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.3); display: none;
            justify-content: center; align-items: center;
            z-index: 10000; backdrop-filter: blur(5px);
        }
        .modal-content {
            background: white; padding: 30px; border-radius: 20px;
            text-align: center; width: 80%; max-width: 280px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.15); animation: popIn 0.3s;
        }
        @keyframes popIn {
            from { transform: scale(0.8); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }
        .modal-title { font-size: 26px; margin: 0 0 10px 0; color: #40c057; font-weight: 800; }
        .modal-record-label { font-size: 14px; color: #555; margin-bottom: 5px; }
        #clearTimeText { font-size: 24px; font-weight: 800; color: #228be6; }
        .btn-modal {
            background-color: var(--color-active); color: white; border: none;
            padding: 12px 0; width: 100%; border-radius: 10px;
            font-size: 16px; font-weight: bold; cursor: pointer; margin-top: 15px;
        }
    </style>
</head>
<body>

    <div class="game-container">
        <h1>Îß§ÏßÅ ÌïÑ(Magic Fill)</h1>

        <div class="level-panel">
            <div class="level-buttons" id="level-container"></div>
        </div>

        <div class="game-info-bar">
            <div class="info-left">
                <span class="info-title" id="levelTitle">Level 1</span>
                <span class="info-sub" id="gridInfo">5x5</span>
            </div>
            <div class="info-center" id="countDisplay">0/3</div>
            <div class="info-right">
                <div class="timer" id="timer">00:00</div>
            </div>
        </div>

        <div class="game-board-wrapper">
            <div id="board" class="game-board"></div>
            <div id="rowCounts" class="counts-row"></div>
            <div id="colCounts" class="counts-col"></div>
        </div>

        <div id="msgArea" class="msg-area"></div>

        <div class="palette-area" id="paletteArea">
            <div class="palette-label" id="paletteLabel"></div>
            <div class="palette-shape-container" id="paletteShape"></div>
        </div>

        <div class="controls">
            <label class="chk-wrapper">
                <input type="checkbox" id="chkShowCounts" onchange="toggleCounts()">
                ÏÖÄ Í∞ØÏàò
            </label>
            <button class="btn-ctrl btn-hint" onclick="useHint()">
                <svg viewBox="0 0 24 24"><path d="M9 21c0 .55.45 1 1 1h4c.55 0 1-.45 1-1v-1H9v1zm3-19C8.14 2 5 5.14 5 9c0 2.38 1.19 4.47 3 5.74V17c0 .55.45 1 1 1h6c.55 0 1-.45 1-1v-2.26c1.81-1.27 3-3.36 3-5.74 0-3.86-3.14-7-7-7zm2.85 11.1l-.85.6V16h-4v-2.3l-.85-.6A4.997 4.997 0 0 1 7 9c0-2.76 2.24-5 5-5s5 2.24 5 5c0 1.63-.8 3.16-2.15 4.1z"/></svg>
                ÌûåÌä∏
            </button>
            <button class="btn-ctrl btn-reset" onclick="resetLevel()">Ï¥àÍ∏∞Ìôî</button>
        </div>

        <div class="rules">
            <b>[Í≤åÏûÑ Í∑úÏπô]</b><br>
            1. <b>Î™©Ìëú:</b> Î™®ÏñëÏùÑ Î∞∞ÏπòÌïòÏó¨ Î™©Ìëú Í∞úÏàòÎ•º Ï±ÑÏö∞ÏÑ∏Ïöî.<br>
            2. <span class="highlight">Ï§ëÏöî: Í∞Å Í∞ÄÎ°úÏ§ÑÍ≥º ÏÑ∏Î°úÏ§ÑÏóê Ï±ÑÏõåÏßÄÎäî Ïπ∏Ïùò Í∞úÏàòÍ∞Ä Î™®Îëê ÎèôÏùºÌï¥Ïïº Ìï©ÎãàÎã§.</span><br>
            3. <b>ÌöåÏ†Ñ:</b> Î™®ÏñëÏùÑ <b>ÌÅ¥Î¶≠</b>ÌïòÎ©¥ ÌöåÏ†ÑÌï©ÎãàÎã§.<br>
            4. <b>Î∞∞Ïπò:</b> ÎìúÎûòÍ∑∏ÌïòÏó¨ Í≤©ÏûêÏóê ÎÜìÏúºÏÑ∏Ïöî.<br>
            5. Î™®ÏñëÎÅºÎ¶¨ Í≤πÏπòÍ±∞ÎÇò Í≤©ÏûêÎ•º Î≤óÏñ¥ÎÇ† Ïàò ÏóÜÏäµÎãàÎã§.
        </div>
    </div>

    <div id="successModal" class="modal-overlay">
        <div class="modal-content">
            <h2 class="modal-title">üéâ Clear!</h2>
            <div class="modal-record-label">Í∏∞Î°ù</div>
            <div id="clearTimeText"></div>
            <button class="btn-modal" onclick="closeModal()">ÌôïÏù∏</button>
        </div>
    </div>

    <script>
        const LEVELS = [
            { 
                id: 1, size: 5, target: 4, shape: [[1,1,1], [1,0,1]], 
                fixedPos: { r: 3, c: 2, rot: 0 },
                solutions: [
                    { r: 3, c: 2, rot: 0 }, 
                    { r: 2, c: 0, rot: 1 }, 
                    { r: 0, c: 0, rot: 2 }, 
                    { r: 0, c: 3, rot: 3 }  
                ]
            },
            { 
                id: 2, size: 6, target: 4, shape: [[0,1,1,0], [1,1,1,1]], 
                fixedPos: { r: 4, c: 1, rot: 0 },
                solutions: [
                    { r: 4, c: 1, rot: 0 },
                    { r: 1, c: 0, rot: 1 },
                    { r: 0, c: 1, rot: 2 },
                    { r: 1, c: 4, rot: 3 }
                ]
            },
            { 
                id: 3, size: 6, target: 4, shape: [[0,0,1,1], [1,1,1,1]], 
                fixedPos: { r: 4, c: 2, rot: 0 },
                solutions: [
                    { r: 4, c: 2, rot: 0 },
                    { r: 3, c: 0, rot: 2 },
                    { r: 0, c: 0, rot: 2 },
                    { r: 1, c: 2, rot: 0 }
                ]
            },
            { 
                id: 4, size: 8, target: 8, shape: [[1,1,1,1],[1,0,0,1]], 
                fixedPos: { r: 6, c: 4, rot: 0 },
                solutions: [
                    { r: 6, c: 4, rot: 0 },
                    { r: 4, c: 0, rot: 1 }, { r: 0, c: 0, rot: 2 }, { r: 0, c: 6, rot: 3 },
                    { r: 4, c: 2, rot: 3 }, { r: 2, c: 0, rot: 0 }, { r: 0, c: 4, rot: 1 },
                    { r: 4, c: 4, rot: 2 }
                ]
            },
            { 
                id: 5, size: 8, target: 8, shape: [[0,0,1,0], [1,1,1,1]], 
                fixedPos: { r: 6, c: 4, rot: 0 },
                solutions: [
                    { r: 6, c: 4, rot: 0 },
                    { r: 6, c: 2, rot: 2 }, { r: 0, c: 0, rot: 3 }, { r: 2, c: 0, rot: 1 },
                    { r: 1, c: 2, rot: 1 }, { r: 0, c: 3, rot: 2 }, { r: 1, c: 6, rot: 3 },
                    { r: 4, c: 3, rot: 4 }
                ]
            },
            { 
                id: 6, size: 8, target: 8, shape: [[0,0,0,1,1],[1,1,1,1,1]], 
                fixedPos: { r: 6, c: 1, rot: 0 },
                solutions: [
                    { r: 6, c: 1, rot: 0 },
                    { r: 3, c: 6, rot: 1 }, { r: 0, c: 6, rot: 3 }, { r: 0, c: 0, rot: 2 },
                    { r: 2, c: 0, rot: 1 }, { r: 2, c: 1, rot: 3 }, { r: 1, c: 3, rot: 1 },
                    { r: 1, c: 4, rot: 3 }
                ]
            },
            { 
                id: 7, size: 12, target: 8, shape: [[0,0,1],[0,0,1],[1,1,1],[1,0,0]], 
                fixedPos: { r: 8, c: 9, rot: 0 },
                solutions: [
                    { r: 8, c: 9, rot: 0 },
                    { r: 9, c: 0, rot: 1 }, { r: 0, c: 0, rot: 2 }, { r: 0, c: 8, rot: 3 },
                    { r: 2, c: 3, rot: 0 }, { r: 3, c: 6, rot: 1 }, { r: 6, c: 6, rot: 2 },
                    { r: 6, c: 2, rot: 3 }
                ]
            },
            { 
                id: 8, size: 12, target: 8, shape: [[0,0,0,1,1], [1,1,1,1,0]], 
                fixedPos: { r: 10, c: 6, rot: 0 },
                solutions: [
                    { r: 10, c: 6, rot: 0 },
                    { r: 9, c: 4, rot: 2 }, { r: 7, c: 6, rot: 0 }, { r: 3, c: 0, rot: 1 },
                    { r: 1, c: 1, rot: 3 }, { r: 3, c: 3, rot: 1 }, { r: 0, c: 4, rot: 2 },
                    { r: 1, c: 10, rot: 3 }
                ]
            },
            { 
                id: 9, size: 10, target: 10, shape: [[1,1,0,0,0,0], [0,1,1,1,1,1]], 
                fixedPos: { r: 8, c: 3, rot: 0 },
                solutions: [
                    { r: 8, c: 3, rot: 0 },
                    { r: 7, c: 4, rot: 2 }, { r: 0, c: 0, rot: 1 }, { r: 4, c: 0, rot: 3 },
                    { r: 0, c: 3, rot: 2 }, { r: 1, c: 2, rot: 0 }, { r: 0, c: 8, rot: 3 },
                    { r: 3, c: 2, rot: 2 }, { r: 4, c: 2, rot: 1 }, { r: 5, c: 4, rot: 0 }
                ]
            }
        ];

        const levelStates = {}; 
        const levelHintCounts = {}; 

        let currentLevelIdx = 0;
        let activeShapes = []; 
        let shapeIdCounter = 1;
        let gameActive = false;
        let showCounts = false; 
        
        let timerInterval = null;
        let currentLevelElapsedTime = 0; 
        let sessionStartTime = 0; 
        let paletteRotation = 0; 

        let isDragging = false;
        let dragSource = null; 
        let draggedShapeData = null; 
        let dragStartPos = { x: 0, y: 0 };
        let ghostElement = null;

        const boardElement = document.getElementById('board');
        const rowCountsElement = document.getElementById('rowCounts');
        const colCountsElement = document.getElementById('colCounts');
        
        const timerElement = document.getElementById('timer');
        const paletteShape = document.getElementById('paletteShape');
        const paletteLabel = document.getElementById('paletteLabel');
        const gridInfo = document.getElementById('gridInfo');
        const countDisplay = document.getElementById('countDisplay');
        const msgArea = document.getElementById('msgArea');

        function init() {
            createLevelButtons();
            
            const chk = document.getElementById('chkShowCounts');
            chk.checked = true;
            showCounts = true;

            loadLevel(0);
            
            document.addEventListener('pointermove', handlePointerMove, { passive: false });
            document.addEventListener('pointerup', handlePointerUp);
            document.addEventListener('pointercancel', handlePointerUp);
            
            window.addEventListener('resize', () => {
                requestAnimationFrame(renderBoard);
            });
        }

        function toggleCounts() {
            showCounts = document.getElementById('chkShowCounts').checked;
            renderBoard();
        }

        function getDims(level) {
            if (level.cols && level.rows) return { rows: level.rows, cols: level.cols };
            return { rows: level.size, cols: level.size };
        }

        function createLevelButtons() {
            const container = document.getElementById('level-container');
            container.innerHTML = '';
            LEVELS.forEach((lvl, idx) => {
                const btn = document.createElement('div');
                btn.className = 'level-btn';
                btn.id = `btn-lvl-${lvl.id}`;
                
                const hintCount = levelHintCounts[lvl.id] || 0;
                const hintText = hintCount > 0 ? `(${hintCount})` : '';

                btn.innerHTML = `
                    <span id="lvl-title-${lvl.id}" style="font-size:15px">${lvl.id}Îã®Í≥Ñ${hintText}</span>
                    <span class="lvl-record" id="rec-${lvl.id}"></span>
                `;
                btn.onclick = () => switchLevel(idx);
                container.appendChild(btn);
            });
        }

        function updateLevelBtnText(levelId) {
            const span = document.getElementById(`lvl-title-${levelId}`);
            if(span) {
                const count = levelHintCounts[levelId] || 0;
                const hintText = count > 0 ? `(${count})` : '';
                span.innerText = `${levelId}Îã®Í≥Ñ${hintText}`;
            }
        }

        function switchLevel(newIdx) {
            if (currentLevelIdx === newIdx) return;
            saveCurrentState(); 
            loadLevel(newIdx);  
        }

        function saveCurrentState() {
            if (gameActive) {
                const now = Date.now();
                currentLevelElapsedTime += Math.floor((now - sessionStartTime) / 1000);
            }
            levelStates[currentLevelIdx] = {
                activeShapes: JSON.parse(JSON.stringify(activeShapes)),
                elapsedTime: currentLevelElapsedTime,
                gameActive: gameActive,
                paletteRotation: paletteRotation,
                shapeIdCounter: shapeIdCounter,
                hintCount: levelHintCounts[LEVELS[currentLevelIdx].id] || 0 
            };
        }

        function loadLevel(idx) {
            currentLevelIdx = idx;
            const levelData = LEVELS[idx];
            const dims = getDims(levelData);

            document.querySelectorAll('.level-btn').forEach(b => b.classList.remove('active'));
            document.getElementById(`btn-lvl-${levelData.id}`).classList.add('active');
            
            document.getElementById('levelTitle').innerText = `${levelData.id}Îã®Í≥Ñ`;
            gridInfo.innerText = `${dims.cols}x${dims.rows}`;
            
            document.documentElement.style.setProperty('--board-cols', dims.cols);
            document.documentElement.style.setProperty('--board-rows', dims.rows);
            
            boardElement.style.display = 'grid'; 
            hideMessage();

            if (levelStates[idx]) {
                restoreLevelState(idx);
            } else {
                initLevelData(levelData);
            }
        }

        function initLevelData(levelData) {
            stopTimer();
            gameActive = true;
            activeShapes = [];
            shapeIdCounter = 1;
            paletteRotation = 0;
            currentLevelElapsedTime = 0;
            
            // [ÏàòÏ†ï] ÌûåÌä∏ Ïπ¥Ïö¥Ìä∏Í∞Ä ÏóÜÏùÑ Îïå(ÏµúÏ¥à Ïã§Ìñâ Ïãú)Îßå 0ÏúºÎ°ú Ï¥àÍ∏∞Ìôî
            // Ï¥àÍ∏∞Ìôî Î≤ÑÌäºÏùÑ ÎàåÎü¨ÏÑú Ïù¥ Ìï®ÏàòÍ∞Ä Ïã§ÌñâÎêòÎçîÎùºÎèÑ Í∏∞Ï°¥ Í∞íÏù¥ ÏûàÏúºÎ©¥ Ïú†ÏßÄÎê®
            if (levelHintCounts[levelData.id] === undefined) {
                levelHintCounts[levelData.id] = 0;
            }
            updateLevelBtnText(levelData.id);

            if (levelData.fixedPos) {
                activeShapes.push({
                    id: shapeIdCounter++,
                    r: levelData.fixedPos.r,
                    c: levelData.fixedPos.c,
                    rot: levelData.fixedPos.rot,
                    isFixed: true
                });
            }

            renderBoard();
            renderPalette();
            updateGameUI();
            startTimer();
        }

        function restoreLevelState(idx) {
            const state = levelStates[idx];
            stopTimer();
            
            activeShapes = JSON.parse(JSON.stringify(state.activeShapes));
            currentLevelElapsedTime = state.elapsedTime;
            gameActive = state.gameActive;
            paletteRotation = state.paletteRotation;
            shapeIdCounter = state.shapeIdCounter;
            
            levelHintCounts[LEVELS[idx].id] = state.hintCount || 0;
            updateLevelBtnText(LEVELS[idx].id);

            renderBoard();
            renderPalette();
            updateGameUI();
            updateTimerDisplay(currentLevelElapsedTime);

            if (gameActive) {
                startTimer();
            }
        }

        function resetLevel() {
            delete levelStates[currentLevelIdx];
            loadLevel(currentLevelIdx);
        }

        function renderPalette() {
            const level = LEVELS[currentLevelIdx];
            const matrix = getRotatedShape(level.shape, paletteRotation);

            paletteShape.innerHTML = '';
            const rows = matrix.length;
            const cols = matrix[0].length;
            const miniGrid = document.createElement('div');
            miniGrid.className = 'mini-grid';
            miniGrid.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;
            
            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    const cell = document.createElement('div');
                    cell.className = 'mini-cell ' + (matrix[r][c] ? 'filled' : '');
                    miniGrid.appendChild(cell);
                }
            }
            paletteShape.appendChild(miniGrid);
            paletteShape.onpointerdown = (e) => startDrag(e, 'palette');
        }

        function updateGameUI() {
            const level = LEVELS[currentLevelIdx];
            const currentCount = activeShapes.length;
            
            countDisplay.innerText = `${currentCount}/${level.target}`;
            if (currentCount === level.target) {
                countDisplay.classList.add('full');
            } else {
                countDisplay.classList.remove('full');
            }

            if (currentCount >= level.target) {
                paletteShape.style.opacity = '0.3';
                paletteShape.style.pointerEvents = 'none';
                paletteLabel.innerText = "Î™®Îëê Î∞∞ÏπòÏôÑÎ£å";
            } else {
                paletteShape.style.opacity = '1';
                paletteShape.style.pointerEvents = 'auto';
                paletteLabel.innerText = "ÌÅ¥Î¶≠ÌïòÏó¨ ÌöåÏ†Ñ / ÎìúÎûòÍ∑∏ÌïòÏó¨ Î∞∞Ïπò";
            }
        }

        function renderBoard() {
            const level = LEVELS[currentLevelIdx];
            const dims = getDims(level);
            const totalCells = dims.rows * dims.cols;
            
            boardElement.innerHTML = '';
            rowCountsElement.innerHTML = '';
            colCountsElement.innerHTML = '';

            const boardRect = boardElement.getBoundingClientRect();
            if (boardRect.width > 0) {
                const cellSize = boardRect.width / dims.cols;
                document.documentElement.style.setProperty('--cell-size', cellSize + 'px');
            }

            const gridMap = new Array(totalCells).fill(null);
            
            activeShapes.forEach(shape => {
                const cells = getOccupiedCells(shape);
                cells.forEach(cell => {
                    if (isValidPos(cell.r, cell.c)) {
                        const idx = cell.r * dims.cols + cell.c;
                        if (gridMap[idx] !== null) gridMap[idx] = 'collision';
                        else gridMap[idx] = shape.id;
                    }
                });
            });

            // Î≥¥Îìú Î†åÎçîÎßÅ
            for (let i = 0; i < totalCells; i++) {
                const cellDiv = document.createElement('div');
                cellDiv.className = 'cell';
                cellDiv.dataset.idx = i;
                
                const val = gridMap[i];
                const r = Math.floor(i / dims.cols);
                const c = i % dims.cols;

                if (val === 'collision') {
                    cellDiv.classList.add('shape', 'error');
                } else if (val !== null) {
                    cellDiv.classList.add('shape');
                    if (r === 0 || gridMap[(r-1)*dims.cols + c] !== val) cellDiv.classList.add('b-top');
                    if (r === dims.rows-1 || gridMap[(r+1)*dims.cols + c] !== val) cellDiv.classList.add('b-bottom');
                    if (c === 0 || gridMap[r*dims.cols + (c-1)] !== val) cellDiv.classList.add('b-left');
                    if (c === dims.cols-1 || gridMap[r*dims.cols + (c+1)] !== val) cellDiv.classList.add('b-right');

                    const shapeObj = activeShapes.find(s => s.id === val);
                    if (shapeObj && shapeObj.isFixed) cellDiv.classList.add('fixed');
                    else if (shapeObj) cellDiv.onpointerdown = (e) => startDrag(e, 'board', shapeObj, i);
                }
                
                cellDiv.oncontextmenu = (e) => e.preventDefault();
                boardElement.appendChild(cellDiv);
            }

            // Î™©Ìëú Í∞úÏàò Í≥ÑÏÇ∞
            let cellsPerShape = 0;
            level.shape.forEach(row => row.forEach(v => { if(v) cellsPerShape++; }));
            const totalTargetCells = cellsPerShape * level.target;
            const targetPerRow = totalTargetCells / dims.rows;
            const targetPerCol = totalTargetCells / dims.cols;

            // ÌòÑÏû¨ Ìï©Í≥Ñ Í≥ÑÏÇ∞
            const rowSums = new Array(dims.rows).fill(0);
            const colSums = new Array(dims.cols).fill(0);
            for (let i = 0; i < totalCells; i++) {
                if (gridMap[i] !== null) { 
                    const r = Math.floor(i / dims.cols);
                    const c = i % dims.cols;
                    rowSums[r]++;
                    colSums[c]++;
                }
            }

            // Í∞ÄÎ°ú Ìï©Í≥Ñ Î†åÎçîÎßÅ
            for(let r=0; r<dims.rows; r++) {
                const div = document.createElement('div');
                div.className = 'count-cell' + (showCounts ? ' visible' : '');
                
                if (rowSums[r] === targetPerRow) div.classList.add('correct');
                else if (rowSums[r] > targetPerRow) div.classList.add('excess');

                div.innerText = rowSums[r];
                rowCountsElement.appendChild(div);
            }

            // ÏÑ∏Î°ú Ìï©Í≥Ñ Î†åÎçîÎßÅ
            for(let c=0; c<dims.cols; c++) {
                const div = document.createElement('div');
                div.className = 'count-cell' + (showCounts ? ' visible' : '');
                
                if (colSums[c] === targetPerCol) div.classList.add('correct');
                else if (colSums[c] > targetPerCol) div.classList.add('excess');

                div.innerText = colSums[c];
                colCountsElement.appendChild(div);
            }
        }

        // --- ÌûåÌä∏ Î°úÏßÅ (Solutions Í∏∞Î∞ò) ---
        function useHint() {
            if (!gameActive) return;
            const level = LEVELS[currentLevelIdx];
            
            if (!level.solutions) {
                showMessage("Ïù¥ Î†àÎ≤®Ïùò Ï†ïÎãµ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏäµÎãàÎã§.", "error");
                return;
            }

            if (activeShapes.length >= level.target) {
                showMessage("Ïù¥ÎØ∏ Î™®Îì† Î™®ÏñëÏù¥ Î∞∞ÏπòÎêòÏóàÏäµÎãàÎã§.", "info");
                return;
            }

            const nextPiece = level.solutions.find(sol => {
                const exists = activeShapes.some(active => 
                    active.r === sol.r && 
                    active.c === sol.c && 
                    active.rot === sol.rot
                );
                return !exists;
            });

            if (nextPiece) {
                activeShapes.push({
                    id: shapeIdCounter++,
                    r: nextPiece.r,
                    c: nextPiece.c,
                    rot: nextPiece.rot,
                    isFixed: true 
                });
                
                levelHintCounts[level.id] = (levelHintCounts[level.id] || 0) + 1;
                updateLevelBtnText(level.id);

                renderBoard();
                updateGameUI();
                checkAutoWin();
                showMessage("Ï†ïÎãµ ÏúÑÏπòÏóê Î∞∞ÏπòÌñàÏäµÎãàÎã§.", "info");
            } else {
                showMessage("Îçî Ïù¥ÏÉÅ Î∞∞ÏπòÌï† Ï†ïÎãµ ÏúÑÏπòÍ∞Ä ÏóÜÏäµÎãàÎã§.", "info");
            }
        }

        // --- Drag & Drop ---

        function startDrag(e, source, shapeObj = null, cellIdx = -1) {
            if (!gameActive) return;
            e.preventDefault();

            isDragging = true;
            dragSource = source;
            dragStartPos = { x: e.clientX, y: e.clientY };
            
            const level = LEVELS[currentLevelIdx];
            const dims = getDims(level);

            if (source === 'palette') {
                const matrix = getRotatedShape(level.shape, paletteRotation);
                draggedShapeData = {
                    id: shapeIdCounter++, 
                    rot: paletteRotation, 
                    matrix: matrix,
                    centerR: Math.floor(matrix.length / 2),
                    centerC: Math.floor(matrix[0].length / 2)
                };
            } else if (source === 'board') {
                if (shapeObj.isFixed) return;
                
                draggedShapeData = {
                    id: shapeObj.id,
                    r: shapeObj.r,
                    c: shapeObj.c,
                    rot: shapeObj.rot,
                    matrix: getRotatedShape(level.shape, shapeObj.rot),
                    originalR: shapeObj.r,
                    originalC: shapeObj.c,
                    originalRot: shapeObj.rot
                };
                
                const clickR = Math.floor(cellIdx / dims.cols);
                const clickC = cellIdx % dims.cols;
                draggedShapeData.offsetR = clickR - shapeObj.r;
                draggedShapeData.offsetC = clickC - shapeObj.c;
                
                activeShapes = activeShapes.filter(s => s.id !== shapeObj.id);
                renderBoard(); 
            }

            createGhost(e.clientX, e.clientY, draggedShapeData.matrix);
        }

        function createGhost(x, y, matrix) {
            if (ghostElement) ghostElement.remove();
            
            ghostElement = document.createElement('div');
            ghostElement.className = 'ghost-shape';
            
            const rows = matrix.length;
            const cols = matrix[0].length;
            const boardRect = boardElement.getBoundingClientRect();
            const dims = getDims(LEVELS[currentLevelIdx]);
            const cellSize = boardRect.width / dims.cols;
            
            document.documentElement.style.setProperty('--cell-size', cellSize + 'px');

            ghostElement.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            ghostElement.style.gridTemplateRows = `repeat(${rows}, ${cellSize}px)`;

            for(let r=0; r<rows; r++){
                for(let c=0; c<cols; c++){
                    const cell = document.createElement('div');
                    if (matrix[r][c]) {
                        cell.className = 'ghost-cell';
                        if (r===0 || matrix[r-1][c]===0) cell.classList.add('b-top');
                        if (r===rows-1 || matrix[r+1][c]===0) cell.classList.add('b-bottom');
                        if (c===0 || matrix[r][c-1]===0) cell.classList.add('b-left');
                        if (c===cols-1 || matrix[r][c+1]===0) cell.classList.add('b-right');
                    }
                    ghostElement.appendChild(cell);
                }
            }
            document.body.appendChild(ghostElement);
            moveGhost(x, y);
        }

        function moveGhost(x, y) {
            if (!ghostElement) return;
            ghostElement.style.left = x + 'px';
            ghostElement.style.top = y + 'px';
            updateGridPreview(x, y);
        }

        function updateGridPreview(x, y) {
            clearPreview();
            
            const boardRect = boardElement.getBoundingClientRect();
            const level = LEVELS[currentLevelIdx];
            const dims = getDims(level);
            const cellSize = boardRect.width / dims.cols;

            if (x < boardRect.left || x > boardRect.right || y < boardRect.top || y > boardRect.bottom) return;

            const dropC = Math.floor((x - boardRect.left) / cellSize);
            const dropR = Math.floor((y - boardRect.top) / cellSize);

            let targetR, targetC;
            if (dragSource === 'palette') {
                targetR = dropR - draggedShapeData.centerR;
                targetC = dropC - draggedShapeData.centerC;
            } else {
                targetR = dropR - draggedShapeData.offsetR;
                targetC = dropC - draggedShapeData.offsetC;
            }

            const matrix = draggedShapeData.matrix;
            const cellsDOM = boardElement.children;
            let isValid = true;
            const previewCells = [];

            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[0].length; c++){
                    if(matrix[r][c] === 1) {
                        const br = targetR + r;
                        const bc = targetC + c;
                        if (!isValidPos(br, bc)) {
                            isValid = false; 
                        } else {
                            previewCells.push(br * dims.cols + bc);
                        }
                    }
                }
            }
            
            if (isValid) {
                previewCells.forEach(idx => cellsDOM[idx]?.classList.add('preview-valid'));
            } else {
                previewCells.forEach(idx => cellsDOM[idx]?.classList.add('preview-invalid'));
            }
        }

        function clearPreview() {
            const cells = boardElement.children;
            for(let i=0; i<cells.length; i++) {
                cells[i].classList.remove('preview-valid', 'preview-invalid');
            }
        }

        function handlePointerMove(e) {
            if (!isDragging) return;
            e.preventDefault();
            moveGhost(e.clientX, e.clientY);
        }

        function handlePointerUp(e) {
            if (!isDragging) return;
            isDragging = false;
            if (ghostElement) ghostElement.remove();
            ghostElement = null;
            clearPreview();

            const dist = Math.hypot(e.clientX - dragStartPos.x, e.clientY - dragStartPos.y);
            const isClick = dist < 10;

            if (isClick) {
                if (dragSource === 'board') {
                    handleBoardRotation();
                } else if (dragSource === 'palette') {
                    paletteRotation = (paletteRotation + 1) % 4;
                    renderPalette();
                    showMessage("Î™®Ïñë ÌöåÏ†ÑÎê®", "info");
                }
            } else {
                handleDrop(e.clientX, e.clientY);
            }
            
            dragSource = null;
            draggedShapeData = null;
        }

        function handleDrop(x, y) {
            const boardRect = boardElement.getBoundingClientRect();
            const level = LEVELS[currentLevelIdx];
            const dims = getDims(level);
            const cellSize = boardRect.width / dims.cols;

            if (x < boardRect.left || x > boardRect.right || y < boardRect.top || y > boardRect.bottom) {
                if (dragSource === 'board') {
                    showMessage("ÏÇ≠Ï†úÎê®", "info");
                    renderBoard();
                    updateGameUI();
                } else {
                    renderBoard(); 
                }
                return;
            }

            const dropC = Math.floor((x - boardRect.left) / cellSize);
            const dropR = Math.floor((y - boardRect.top) / cellSize);

            let finalR, finalC;
            if (dragSource === 'palette') {
                finalR = dropR - draggedShapeData.centerR;
                finalC = dropC - draggedShapeData.centerC;
            } else {
                finalR = dropR - draggedShapeData.offsetR;
                finalC = dropC - draggedShapeData.offsetC;
            }

            const matrix = draggedShapeData.matrix;
            let isOutOfBounds = false;
            for(let r=0; r<matrix.length; r++){
                for(let c=0; c<matrix[0].length; c++){
                    if(matrix[r][c] === 1) {
                        if (!isValidPos(finalR + r, finalC + c)) {
                            isOutOfBounds = true;
                            break;
                        }
                    }
                }
            }

            if (isOutOfBounds) {
                if (dragSource === 'board') {
                    activeShapes.push({
                        id: draggedShapeData.id,
                        r: draggedShapeData.originalR,
                        c: draggedShapeData.originalC,
                        rot: draggedShapeData.originalRot,
                        isFixed: false
                    });
                    showMessage("Í≤©ÏûêÎ•º Î≤óÏñ¥ÎÇ† Ïàò ÏóÜÏäµÎãàÎã§.", "error");
                }
                renderBoard();
                return;
            }

            activeShapes.push({
                id: draggedShapeData.id,
                r: finalR,
                c: finalC,
                rot: draggedShapeData.rot,
                isFixed: false
            });
            
            renderBoard();
            updateGameUI();
            checkAutoWin();
        }

        function handleBoardRotation() {
            const level = LEVELS[currentLevelIdx];
            const oldRot = draggedShapeData.rot;
            const newRot = (oldRot + 1) % 4;
            const currentMatrix = draggedShapeData.matrix;
            const newMatrix = getRotatedShape(level.shape, newRot);
            
            const offsetR = draggedShapeData.offsetR;
            const offsetC = draggedShapeData.offsetC;
            const height = currentMatrix.length;
            
            const newOffsetR = offsetC;
            const newOffsetC = height - 1 - offsetR;

            const globalPivotR = draggedShapeData.originalR + offsetR;
            const globalPivotC = draggedShapeData.originalC + offsetC;

            const targetR = globalPivotR - newOffsetR;
            const targetC = globalPivotC - newOffsetC;

            let isOutOfBounds = false;
            for(let r=0; r<newMatrix.length; r++){
                for(let c=0; c<newMatrix[0].length; c++){
                    if(newMatrix[r][c] === 1) {
                        if (!isValidPos(targetR + r, targetC + c)) {
                            isOutOfBounds = true;
                            break;
                        }
                    }
                }
            }

            if (isOutOfBounds) {
                showMessage("ÌöåÏ†Ñ Ïãú Í≤©ÏûêÎ•º Î≤óÏñ¥ÎÇ©ÎãàÎã§.", "error");
                activeShapes.push({
                    id: draggedShapeData.id,
                    r: draggedShapeData.originalR,
                    c: draggedShapeData.originalC,
                    rot: draggedShapeData.originalRot,
                    isFixed: false
                });
            } else {
                activeShapes.push({
                    id: draggedShapeData.id,
                    r: targetR,
                    c: targetC,
                    rot: newRot,
                    isFixed: false
                });
                showMessage("Î™®Ïñë ÌöåÏ†ÑÎê®", "info");
            }
            renderBoard();
            checkAutoWin();
        }

        function getRotatedShape(baseShape, rot) {
            let matrix = JSON.parse(JSON.stringify(baseShape));
            for (let i = 0; i < (rot % 4); i++) matrix = rotate90(matrix);
            return matrix;
        }

        function rotate90(matrix) {
            const rows = matrix.length;
            const cols = matrix[0].length;
            let newMatrix = Array.from({ length: cols }, () => Array(rows).fill(0));
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) newMatrix[c][rows - 1 - r] = matrix[r][c];
            }
            return newMatrix;
        }

        function getOccupiedCells(shapeInstance) {
            const level = LEVELS[currentLevelIdx];
            const matrix = getRotatedShape(level.shape, shapeInstance.rot);
            const cells = [];
            for (let r = 0; r < matrix.length; r++) {
                for (let c = 0; c < matrix[0].length; c++) {
                    if (matrix[r][c] === 1) cells.push({ r: shapeInstance.r + r, c: shapeInstance.c + c });
                }
            }
            return cells;
        }

        function isValidPos(r, c) {
            const dims = getDims(LEVELS[currentLevelIdx]);
            return r >= 0 && r < dims.rows && c >= 0 && c < dims.cols;
        }

        function checkAutoWin() {
            if (!gameActive) return;
            const level = LEVELS[currentLevelIdx];
            const dims = getDims(level);
            
            if (activeShapes.length !== level.target) return;

            const gridState = Array.from({ length: dims.rows }, () => Array(dims.cols).fill(0));
            let isOverlap = false;

            for(const s of activeShapes) {
                const cells = getOccupiedCells(s);
                for(const cell of cells) {
                    if (gridState[cell.r][cell.c] !== 0) {
                        isOverlap = true;
                        break;
                    }
                    gridState[cell.r][cell.c] = 1;
                }
                if(isOverlap) break;
            }

            if (isOverlap) return; 

            let totalFilled = 0;
            const rowSums = new Array(dims.rows).fill(0);
            const colSums = new Array(dims.cols).fill(0);

            for(let r=0; r<dims.rows; r++) {
                for(let c=0; c<dims.cols; c++) {
                    if (gridState[r][c] === 1) {
                        rowSums[r]++;
                        colSums[c]++;
                        totalFilled++;
                    }
                }
            }

            if (totalFilled % dims.rows !== 0) return; 
            const expectedRow = totalFilled / dims.rows;
            for(let r=0; r<dims.rows; r++) {
                if (rowSums[r] !== expectedRow) {
                     showMessage(`Î™®Îì† Í∞ÄÎ°úÏ§ÑÏùò Ïπ∏ ÏàòÍ∞Ä ${expectedRow}Í∞úÍ∞Ä ÎêòÏñ¥Ïïº Ìï©ÎãàÎã§.`, "error");
                     return;
                }
            }

            if (totalFilled % dims.cols !== 0) return; 
            const expectedCol = totalFilled / dims.cols;
            for(let c=0; c<dims.cols; c++) {
                if (colSums[c] !== expectedCol) {
                    showMessage(`Î™®Îì† ÏÑ∏Î°úÏ§ÑÏùò Ïπ∏ ÏàòÍ∞Ä ${expectedCol}Í∞úÍ∞Ä ÎêòÏñ¥Ïïº Ìï©ÎãàÎã§.`, "error");
                    return;
                }
            }
            
            gameWin();
        }

        function gameWin() {
            gameActive = false;
            stopTimer();
            const now = Date.now();
            currentLevelElapsedTime += Math.floor((now - sessionStartTime) / 1000);
            
            const timeStr = formatTime(currentLevelElapsedTime);
            const levelId = LEVELS[currentLevelIdx].id;
            
            const btn = document.getElementById(`btn-lvl-${levelId}`);
            if(btn) {
                btn.classList.add('cleared');
                const recSpan = document.getElementById(`rec-${levelId}`);
                if (recSpan) recSpan.innerText = timeStr;
            }

            document.getElementById('clearTimeText').innerText = timeStr;
            document.getElementById('successModal').style.display = 'flex';
        }

        function closeModal() {
            document.getElementById('successModal').style.display = 'none';
        }

        function startTimer() {
            sessionStartTime = Date.now();
            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(() => {
                const now = Date.now();
                const sessionElapsed = Math.floor((now - sessionStartTime) / 1000);
                const totalElapsed = currentLevelElapsedTime + sessionElapsed;
                updateTimerDisplay(totalElapsed);
            }, 1000);
        }

        function updateTimerDisplay(totalSeconds) {
            timerElement.innerText = formatTime(totalSeconds);
        }

        function formatTime(totalSeconds) {
            const m = String(Math.floor(totalSeconds / 60)).padStart(2, '0');
            const s = String(totalSeconds % 60).padStart(2, '0');
            return `${m}:${s}`;
        }

        function stopTimer() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        }

        function showMessage(msg, type = 'info') {
            msgArea.innerText = msg;
            msgArea.className = 'msg-area'; 
            if (type === 'error') {
                msgArea.classList.add('msg-error');
            } else {
                msgArea.classList.add('msg-info');
            }
            msgArea.style.display = 'block';

            if (window.msgTimeout) clearTimeout(window.msgTimeout);
            window.msgTimeout = setTimeout(() => {
                msgArea.style.display = 'none';
            }, 2000);
        }

        function hideMessage() {
            msgArea.style.display = 'none';
        }

        init();
    </script>
</body>
</html>