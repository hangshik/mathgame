<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Î™¨ÎìúÎ¶¨Ïïà Î∏îÎ°ù ÌçºÏ¶ê</title>

<style>
:root {
  --cell: 60px;
}

@media (max-width: 640px) {
  :root {
    --cell: calc( min( 9vw, 44px ) );
  }
  #stage-wrapper, #dock {
    max-width: 100vw;
  }
  body {
    padding: 10px 2px;
  }
  #modal-content {
    padding: 18px 5vw;
  }
  #controls {
    margin: 10px 0;
  }
}

/* Allow board to shrink gracefully and fit mobile screens */
#board {
  touch-action: none;
  position: relative;
  width: calc(var(--cell) * 8);
  height: calc(var(--cell) * 8);
  background: white;
  display: grid;
  grid-template-columns: repeat(8, var(--cell));
  grid-template-rows: repeat(8, var(--cell));
  border: 4px solid black;
  max-width: 98vw;
  max-height: 98vw;
}

body {
  margin: 0;
  font-family: 'Pretendard', -apple-system, sans-serif;
  background: #f1f3f5;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 12px;
  overflow-x: hidden;
}

#stage-wrapper {
  width: 100%;
  max-width: 800px;
  background: white;
  border: 4px solid #343a40;
  border-radius: 16px;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 15px;
  margin-bottom: 20px;
  box-sizing: border-box;
}

#stages {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
  width: 100%;
}

.stage-btn {
  padding: 8px 16px;
  border-radius: 8px;
  border: 2px solid #adb5bd;
  background: white;
  font-weight: 800;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 100px;
  transition: all 0.2s;
  font-size: 1rem;
}
@media (max-width: 480px) {
  .stage-btn {
    min-width: 70px;
    font-size: 0.9rem;
    padding: 7px 6px;
  }
  #timer-display {
    font-size: 1rem;
  }
}

.stage-btn .time-label {
  font-size: 0.8rem;
  font-weight: 400;
  margin-top: 4px;
  opacity: 0.8;
}
.stage-btn.active {
  background: #339af0;
  color: white;
  border-color: #1c7ed6;
}
.stage-btn.cleared {
  background: #51cf66;
  color: white;
  border-color: #37b24d;
}

#timer-display {
  margin-top: 10px;
  font-size: 1.1rem;
  font-weight: 900;
  color: #339af0;
}

/* Í≤åÏûÑ Î≥¥Îìú */
.cell { border: 1px solid #eee; box-sizing: border-box; }

.block {
  position: absolute;
  border: 4px solid black;
  box-sizing: border-box;
  cursor: grab;
  z-index: 1000;
  touch-action: none;
}

#dock {
  width: 100%;
  max-width: 800px;
  min-height: 140px;
  margin-top: 20px;
  background: #dee2e6;
  border: 3px solid #adb5bd;
  border-radius: 12px;
  padding: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
  overflow-x: auto;
}

#dock .block {
  position: relative !important;
  transform: scale(0.45);
  transform-origin: center;
  margin: -15px;
}

.dragging {
  position: fixed !important;
  transform: scale(1) !important;
  margin: 0 !important;
  opacity: 0.85;
  z-index: 9999 !important;
  pointer-events: none;
}

.preview { position: absolute; pointer-events: none; z-index: 500; }
.preview.ok { background: rgba(0, 123, 255, 0.4); border: 3px dashed #007bff; }
.preview.bad { background: rgba(255, 0, 0, 0.4); border: 3px dashed #ff0000; }

#controls { margin: 20px; }
button.reset-btn {
  padding: 12px 30px;
  border-radius: 8px;
  border: none;
  background: #fa5252;
  color: white;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 0 #e03131;
  font-size: 1rem;
}
@media (max-width: 480px) {
  button.reset-btn {
    font-size: 0.92rem;
    padding: 10px 18px;
  }
}

/* ÏÑ±Í≥µ ÌåùÏóÖ Î™®Îã¨ */
#modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(8px);
  z-index: 10000;
  justify-content: center;
  align-items: center;
}
#modal-content {
  background: white;
  padding: 30px 50px;
  border-radius: 20px;
  border: 4px solid #343a40;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.1);
  max-width: 95vw;
  box-sizing: border-box;
}
#modal-content h2 { margin-top: 0; font-size: 2rem; color: #51cf66; }
#modal-content p { font-size: 1.2rem; margin-bottom: 25px; }
#modal-content button {
  padding: 10px 30px;
  font-size: 1.1rem;
  background: #339af0;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}
@media (max-width: 480px) {
  #modal-content {
    padding: 16px 8vw;
  }
  #modal-content h2 {
    font-size: 1.25rem;
  }
  #modal-content p {
    font-size: 1rem;
  }
  #modal-content button {
    font-size: 1rem;
    padding: 8px 20px;
  }
}
</style>
</head>

<body>

  <h2 style="text-align:center;font-size:clamp(1.3rem,4vw,2.2rem)">Î™¨ÎìúÎ¶¨Ïïà Î∏îÎ°ù ÌçºÏ¶ê</h2>
<div id="stage-wrapper">
  <div id="stages"></div>
  <div id="timer-display">ÏãúÍ∞Ñ: 0.0s</div>
</div>

<div id="board"></div>
<div id="dock"></div>

<div id="controls">
  <button class="reset-btn" onclick="resetCurrentStageOnly()">ÌòÑÏû¨ Îã®Í≥Ñ Ï¥àÍ∏∞Ìôî</button>
</div>

<div id="modal-overlay">
  <div id="modal-content">
    <h2>üéâ ÏÑ±Í≥µ!</h2>
    <p id="clear-time-text">Í∏∞Î°ù: 0.0Ï¥à</p>
    <button onclick="closeModal()">ÌôïÏù∏</button>
  </div>
</div>

<script>
const cell = parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'), 10);
const board = document.getElementById("board");
const dock = document.getElementById("dock");
const stagesEl = document.getElementById("stages");
const timerEl = document.getElementById("timer-display");
const modal = document.getElementById("modal-overlay");

let currentStage = 1;
let startTime = 0;
let timerInterval = null;
let clearedTime = {};

let stageHistory = {
  1: { placed: [] },
  2: { placed: [] },
  3: { placed: [] }
};

const stages = {
  1: { fixed: [{x:0,y:2,w:3,h:1},{x:2,y:1,w:1,h:1},{x:3,y:6,w:2,h:1}] },
  2: { fixed: [{x:0,y:7,w:1,h:1},{x:0,y:5,w:2,h:1},{x:3,y:2,w:3,h:1}] },
  3: { fixed: [{x:2,y:3,w:1,h:1},{x:5,y:0,w:1,h:2},{x:7,y:3,w:1,h:3}] }
};

const movableBlocksInfo = [
  {id:'m1',w:2,h:2,c:"#fff"},
  {id:'m2',w:3,h:3,c:"#fff"},
  {id:'m3',w:2,h:3,c:"#fa5252"},
  {id:'m4',w:2,h:4,c:"#fa5252"},
  {id:'m5',w:2,h:5,c:"#fa5252"},
  {id:'m6',w:1,h:4,c:"#339af0"},
  {id:'m7',w:1,h:5,c:"#339af0"},
  {id:'m8',w:3,h:4,c:"#fcc419"}
];

// For resizing on orientation change
window.addEventListener('resize', () => {
  refreshUI();
});

let blockStates = {};
movableBlocksInfo.forEach(b => blockStates[b.id] = { w: b.w, h: b.h });

function buildGrid() {
  board.innerHTML = "";
  for (let i = 0; i < 64; i++) {
    const c = document.createElement("div");
    c.className = "cell";
    board.appendChild(c);
  }
}

// Board rendering
function renderBoard() {
  buildGrid();
  stages[currentStage].fixed.forEach(b => {
    const d = document.createElement("div");
    d.className = "block";
    Object.assign(d.style, {
      left: b.x * getCell() + "px", top: b.y * getCell() + "px",
      width: b.w * getCell() + "px", height: b.h * getCell() + "px",
      background: "black", zIndex: 10
    });
    board.appendChild(d);
  });

  stageHistory[currentStage].placed.forEach(p => {
    const info = movableBlocksInfo.find(m => m.id === p.id);
    const d = document.createElement("div");
    d.className = "block";
    d.id = p.id;
    d.style.background = info.c;
    d.dataset.w = p.w; d.dataset.h = p.h;
    d.style.width = p.w * getCell() + "px";
    d.style.height = p.h * getCell() + "px";
    d.style.left = p.x * getCell() + "px";
    d.style.top = p.y * getCell() + "px";
    enableDrag(d);
    board.appendChild(d);
  });
}

// Dock rendering
function renderDock() {
  dock.innerHTML = "";
  movableBlocksInfo.forEach(b => {
    if (stageHistory[currentStage].placed.some(p => p.id === b.id)) return;
    const s = blockStates[b.id];
    const d = document.createElement("div");
    d.className = "block";
    d.id = b.id;
    d.style.background = b.c;
    d.dataset.w = s.w; d.dataset.h = s.h;
    d.style.width = s.w * getCell() + "px";
    d.style.height = s.h * getCell() + "px";
    enableDrag(d);
    dock.appendChild(d);
  });
}

function getCell() {
  return parseInt(getComputedStyle(document.documentElement).getPropertyValue('--cell'), 10);
}

function enableDrag(el) {
  let preview = null;
  let dragOffsetX = 0, dragOffsetY = 0;
  let startX = 0, startY = 0;
  let isDragging = false;
  let mouseDownTime = 0;

  // ----------- Desktop (mouse) -----------
  el.onmousedown = e => {
    if (e.button !== 0) return;
    doDragStart(e, "mouse");
  };

  // ----------- Touch device -----------
  el.ontouchstart = e => {
    if (e.touches.length > 1) return;
    doDragStart(e.touches[0], "touch", e);
  };

  // ----------- Drag handler (shared) -----------
  function doDragStart(point, mode, origTouchEvent) {
    if (origTouchEvent) origTouchEvent.preventDefault();
    else point.preventDefault && point.preventDefault();
    mouseDownTime = Date.now();
    const w = +el.dataset.w;
    const h = +el.dataset.h;
    const rect = el.getBoundingClientRect();

    dragOffsetX = (point.clientX - rect.left) * ( (w * getCell()) / rect.width );
    dragOffsetY = (point.clientY - rect.top) * ( (h * getCell()) / rect.height );

    startX = point.clientX; startY = point.clientY;

    const onMove = ev => {
      let clientX, clientY;
      if (mode === "mouse") {
        clientX = ev.clientX; clientY = ev.clientY;
      } else if (mode === "touch") {
        if (ev.touches.length > 1) return;
        clientX = ev.touches[0].clientX; clientY = ev.touches[0].clientY;
      }
      if (!isDragging && Math.hypot(clientX - startX, clientY - startY) > 5) {
        isDragging = true;
        // DockÏóêÏÑúÎäî Î∞∞ÏπòÏ§ëÏùºÎïåÎèÑ Ï†úÍ±∞Ìï¥Ïïº Ï§ëÎ≥µ Î∞©ÏßÄ
        stageHistory[currentStage].placed = stageHistory[currentStage].placed.filter(p => p.id !== el.id);
        if (dock.contains(el)) {
          el.style.left = rect.left + "px"; el.style.top = rect.top + "px";
          el.style.position = "fixed"; document.body.appendChild(el);
        }
        el.classList.add("dragging");
        preview = document.createElement("div");
        preview.className = "preview";
        preview.style.width = w * getCell() + "px"; preview.style.height = h * getCell() + "px";
        board.appendChild(preview);
      }
      if (isDragging) {
        el.style.left = clientX - dragOffsetX + "px";
        el.style.top = clientY - dragOffsetY + "px";
        const br = board.getBoundingClientRect();
        const gx = Math.round((clientX - br.left - dragOffsetX) / getCell());
        const gy = Math.round((clientY - br.top - dragOffsetY) / getCell());
        preview.className = "preview " + (isValid(gx, gy, w, h) ? "ok" : "bad");
        preview.style.left = gx * getCell() + "px"; preview.style.top = gy * getCell() + "px";
      }
    };

    const onUp = ev => {
      let clientX, clientY;
      if (mode === "mouse") {
        document.removeEventListener("mousemove", onMove);
        document.removeEventListener("mouseup", onUp);
        clientX = ev.clientX; clientY = ev.clientY;
      } else {
        document.removeEventListener("touchmove", onMove);
        document.removeEventListener("touchend", onUp);
        const changedTouch = ev.changedTouches ? ev.changedTouches[0] : ev.touches[0];
        clientX = changedTouch.clientX; clientY = changedTouch.clientY;
      }
      const moveDist = Math.hypot(clientX - startX, clientY - startY);

      if (Date.now() - mouseDownTime < 300 && moveDist < 10) {
        // Rotate block
        const state = blockStates[el.id];
        const newW = state.h; const newH = state.w;
        const placedIdx = stageHistory[currentStage].placed.findIndex(p => p.id === el.id);
        if (placedIdx !== -1) {
          const p = stageHistory[currentStage].placed[placedIdx];
          const currentPlaced = stageHistory[currentStage].placed;
          stageHistory[currentStage].placed = currentPlaced.filter(item => item.id !== el.id);
          if (isValid(p.x, p.y, newW, newH)) {
            state.w = newW; state.h = newH;
            stageHistory[currentStage].placed.push({ ...p, w: newW, h: newH });
          } else { stageHistory[currentStage].placed = currentPlaced; }
        } else { state.w = newW; state.h = newH; }
      } else if (isDragging) {
        // Try to place
        const br = board.getBoundingClientRect();
        const gx = Math.round((clientX - br.left - dragOffsetX) / getCell());
        const gy = Math.round((clientY - br.top - dragOffsetY) / getCell());
        if (isValid(gx, gy, w, h)) {
          stageHistory[currentStage].placed.push({ id: el.id, x: gx, y: gy, w, h });
          checkClear();
        }
      }
      preview?.remove(); el.remove(); refreshUI();
    };

    if (mode === "mouse") {
      document.addEventListener("mousemove", onMove);
      document.addEventListener("mouseup", onUp);
    } else if (mode === "touch") {
      document.addEventListener("touchmove", onMove, { passive: false });
      document.addEventListener("touchend", onUp, { passive: false });
    }
  }
}

// ÌåêÎ≥Ñ Ìï®Ïàò
function isValid(x, y, w, h) {
  if (x < 0 || y < 0 || x + w > 8 || y + h > 8) return false;
  if (stages[currentStage].fixed.some(p => x < p.x + p.w && x + w > p.x && y < p.y + p.h && y + h > p.y)) return false;
  return !stageHistory[currentStage].placed.some(p => x < p.x + p.w && x + w > p.x && y < p.y + p.h && y + h > p.y);
}

function refreshUI() {
  renderBoard();
  renderDock();
  renderStages();
}

// ÌÉÄÏù¥Î®∏
function startTimer() {
  clearInterval(timerInterval);
  startTime = Date.now();
  timerInterval = setInterval(() => {
    timerEl.textContent = `ÏãúÍ∞Ñ: ${((Date.now() - startTime) / 1000).toFixed(1)}s`;
  }, 100);
}

function checkClear() {
  if (stageHistory[currentStage].placed.length === movableBlocksInfo.length) {
    clearInterval(timerInterval);
    const t = ((Date.now() - startTime) / 1000).toFixed(1);
    clearedTime[currentStage] = t + "s";
    
    // Î™®Îã¨ ÌëúÏãú
    document.getElementById("clear-time-text").textContent = `Í∏∞Î°ù: ${t}Ï¥à`;
    modal.style.display = "flex";
    // Prevent background scroll on mobile
    document.body.style.overflow = "hidden";
    document.body.style.touchAction = "none";
  }
}

function closeModal() {
  modal.style.display = "none";
  document.body.style.overflow = "";
  document.body.style.touchAction = "";
  // Îã§Ïùå Îã®Í≥ÑÎ°ú Ïù¥Îèô
  if (currentStage < 3) loadStage(currentStage + 1);
  else refreshUI();
}

// Îã®Í≥Ñ Î≤ÑÌäº ÌëúÏãú
function renderStages() {
  stagesEl.innerHTML = "";
  [1, 2, 3].forEach(i => {
    const b = document.createElement("button");
    b.className = "stage-btn" + (i === currentStage ? " active" : "") + (clearedTime[i] ? " cleared" : "");
    
    const nameSpan = document.createElement("span");
    nameSpan.textContent = i + "Îã®Í≥Ñ";
    b.appendChild(nameSpan);

    if (clearedTime[i]) {
      const timeSpan = document.createElement("span");
      timeSpan.className = "time-label";
      timeSpan.textContent = clearedTime[i];
      b.appendChild(timeSpan);
    }

    b.onclick = () => loadStage(i);
    stagesEl.appendChild(b);
  });
}

function loadStage(n) {
  currentStage = n;
  startTimer();
  refreshUI();
}

function resetCurrentStageOnly() {
  stageHistory[currentStage].placed = [];
  refreshUI();
}

// Ï¥àÍ∏∞Ìôî
loadStage(1);

// Prevent scrolling during touch drag on mobile
document.body.addEventListener("touchmove", function(e) {
  if (document.querySelector('.dragging')) e.preventDefault();
}, { passive: false });
</script>

</body>
</html>