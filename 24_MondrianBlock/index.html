<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>ëª¬ë“œë¦¬ì•ˆ ë¸”ë¡ í¼ì¦</title>

<style>
:root { --cell: 60px; }

body {
  margin: 0;
  font-family: 'Pretendard', -apple-system, sans-serif;
  background: #f1f3f5;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 20px 12px;
}

/* ë‹¨ê³„ í‘œì‹œ ì˜ì—­ */
#stage-wrapper {
  width: 100%;
  max-width: 800px;
  background: white;
  border: 4px solid #343a40;
  border-radius: 16px;
  position: relative;
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 15px;
  margin-bottom: 20px;
  box-sizing: border-box;
}

#stages {
  display: flex;
  gap: 12px;
  flex-wrap: wrap;
  justify-content: center;
}

/* ë‹¨ê³„ ë²„íŠ¼ ë‚´ë¶€ ë ˆì´ì•„ì›ƒ */
.stage-btn {
  padding: 8px 16px;
  border-radius: 8px;
  border: 2px solid #adb5bd;
  background: white;
  font-weight: 800;
  cursor: pointer;
  display: flex;
  flex-direction: column;
  align-items: center;
  min-width: 100px;
  transition: all 0.2s;
}
.stage-btn .time-label {
  font-size: 0.8rem;
  font-weight: 400;
  margin-top: 4px;
  opacity: 0.8;
}
.stage-btn.active {
  background: #339af0;
  color: white;
  border-color: #1c7ed6;
}
.stage-btn.cleared {
  background: #51cf66;
  color: white;
  border-color: #37b24d;
}

#timer-display {
  margin-top: 10px;
  font-size: 1.1rem;
  font-weight: 900;
  color: #339af0;
}

/* ê²Œì„ ë³´ë“œ */
#board {
  position: relative;
  width: calc(var(--cell) * 8);
  height: calc(var(--cell) * 8);
  background: white;
  display: grid;
  grid-template-columns: repeat(8, var(--cell));
  grid-template-rows: repeat(8, var(--cell));
  border: 4px solid black;
}
.cell { border: 1px solid #eee; box-sizing: border-box; }

.block {
  position: absolute;
  border: 4px solid black;
  box-sizing: border-box;
  cursor: grab;
  z-index: 1000;
}

#dock {
  width: 100%;
  max-width: 800px;
  min-height: 140px;
  margin-top: 20px;
  background: #dee2e6;
  border: 3px solid #adb5bd;
  border-radius: 12px;
  padding: 10px;
  display: flex;
  flex-wrap: wrap;
  gap: 5px;
  justify-content: center;
  align-items: center;
  box-sizing: border-box;
}
#dock .block {
  position: relative !important;
  transform: scale(0.45);
  transform-origin: center;
  margin: -15px;
}

.dragging {
  position: fixed !important;
  transform: scale(1) !important;
  margin: 0 !important;
  opacity: 0.85;
  z-index: 9999 !important;
  pointer-events: none;
}

.preview { position: absolute; pointer-events: none; z-index: 500; }
.preview.ok { background: rgba(0, 123, 255, 0.4); border: 3px dashed #007bff; }
.preview.bad { background: rgba(255, 0, 0, 0.4); border: 3px dashed #ff0000; }

#controls { margin: 20px; }
button.reset-btn {
  padding: 12px 30px;
  border-radius: 8px;
  border: none;
  background: #fa5252;
  color: white;
  font-weight: bold;
  cursor: pointer;
  box-shadow: 0 4px 0 #e03131;
}

/* ì„±ê³µ íŒì—… ëª¨ë‹¬ */
#modal-overlay {
  display: none;
  position: fixed;
  top: 0; left: 0; width: 100%; height: 100%;
  background: rgba(255, 255, 255, 0.2);
  backdrop-filter: blur(8px);
  z-index: 10000;
  justify-content: center;
  align-items: center;
}
#modal-content {
  background: white;
  padding: 30px 50px;
  border-radius: 20px;
  border: 4px solid #343a40;
  text-align: center;
  box-shadow: 0 10px 30px rgba(0,0,0,0.1);
}
#modal-content h2 { margin-top: 0; font-size: 2rem; color: #51cf66; }
#modal-content p { font-size: 1.2rem; margin-bottom: 25px; }
#modal-content button {
  padding: 10px 30px;
  font-size: 1.1rem;
  background: #339af0;
  color: white;
  border: none;
  border-radius: 8px;
  cursor: pointer;
  font-weight: bold;
}
</style>
</head>

<body>

  <h2>ëª¬ë“œë¦¬ì•ˆ ë¸”ë¡ í¼ì¦</h2>
<div id="stage-wrapper">
  <div id="stages"></div>
  <div id="timer-display">ì‹œê°„: 0.0s</div>
</div>

<div id="board"></div>
<div id="dock"></div>

<div id="controls">
  <button class="reset-btn" onclick="resetCurrentStageOnly()">í˜„ì¬ ë‹¨ê³„ ì´ˆê¸°í™”</button>
</div>

<div id="modal-overlay">
  <div id="modal-content">
    <h2>ğŸ‰ ì„±ê³µ!</h2>
    <p id="clear-time-text">ê¸°ë¡: 0.0ì´ˆ</p>
    <button onclick="closeModal()">í™•ì¸</button>
  </div>
</div>

<script>
const cell = 60;
const board = document.getElementById("board");
const dock = document.getElementById("dock");
const stagesEl = document.getElementById("stages");
const timerEl = document.getElementById("timer-display");
const modal = document.getElementById("modal-overlay");

let currentStage = 1;
let startTime = 0;
let timerInterval = null;
let clearedTime = {};

let stageHistory = {
  1: { placed: [] },
  2: { placed: [] },
  3: { placed: [] }
};

const stages = {
  1: { fixed: [{x:0,y:2,w:3,h:1},{x:2,y:1,w:1,h:1},{x:3,y:6,w:2,h:1}] },
  2: { fixed: [{x:0,y:7,w:1,h:1},{x:0,y:5,w:2,h:1},{x:3,y:2,w:3,h:1}] },
  3: { fixed: [{x:2,y:3,w:1,h:1},{x:5,y:0,w:1,h:2},{x:7,y:3,w:1,h:3}] }
};

const movableBlocksInfo = [
  {id:'m1',w:2,h:2,c:"#fff"},
  {id:'m2',w:3,h:3,c:"#fff"},
  {id:'m3',w:2,h:3,c:"#fa5252"},
  {id:'m4',w:2,h:4,c:"#fa5252"},
  {id:'m5',w:2,h:5,c:"#fa5252"},
  {id:'m6',w:1,h:4,c:"#339af0"},
  {id:'m7',w:1,h:5,c:"#339af0"},
  {id:'m8',w:3,h:4,c:"#fcc419"}
];

let blockStates = {};
movableBlocksInfo.forEach(b => blockStates[b.id] = { w: b.w, h: b.h });

function buildGrid() {
  board.innerHTML = "";
  for (let i = 0; i < 64; i++) {
    const c = document.createElement("div");
    c.className = "cell";
    board.appendChild(c);
  }
}

function renderBoard() {
  buildGrid();
  stages[currentStage].fixed.forEach(b => {
    const d = document.createElement("div");
    d.className = "block";
    Object.assign(d.style, {
      left: b.x * cell + "px", top: b.y * cell + "px",
      width: b.w * cell + "px", height: b.h * cell + "px",
      background: "black", zIndex: 10
    });
    board.appendChild(d);
  });

  stageHistory[currentStage].placed.forEach(p => {
    const info = movableBlocksInfo.find(m => m.id === p.id);
    const d = document.createElement("div");
    d.className = "block";
    d.id = p.id;
    d.style.background = info.c;
    d.dataset.w = p.w; d.dataset.h = p.h;
    d.style.width = p.w * cell + "px";
    d.style.height = p.h * cell + "px";
    d.style.left = p.x * cell + "px";
    d.style.top = p.y * cell + "px";
    enableDrag(d);
    board.appendChild(d);
  });
}

function renderDock() {
  dock.innerHTML = "";
  movableBlocksInfo.forEach(b => {
    if (stageHistory[currentStage].placed.some(p => p.id === b.id)) return;
    const s = blockStates[b.id];
    const d = document.createElement("div");
    d.className = "block";
    d.id = b.id;
    d.style.background = b.c;
    d.dataset.w = s.w; d.dataset.h = s.h;
    d.style.width = s.w * cell + "px";
    d.style.height = s.h * cell + "px";
    enableDrag(d);
    dock.appendChild(d);
  });
}

function enableDrag(el) {
  let preview = null;
  let dragOffsetX = 0, dragOffsetY = 0;
  let startX = 0, startY = 0;
  let isDragging = false;
  let mouseDownTime = 0;

  el.onmousedown = e => {
    e.preventDefault();
    mouseDownTime = Date.now();
    const w = +el.dataset.w;
    const h = +el.dataset.h;
    const rect = el.getBoundingClientRect();

    dragOffsetX = (e.clientX - rect.left) * ( (w * cell) / rect.width );
    dragOffsetY = (e.clientY - rect.top) * ( (h * cell) / rect.height );

    startX = e.clientX; startY = e.clientY;

    const onMove = ev => {
      if (!isDragging && Math.hypot(ev.clientX - startX, ev.clientY - startY) > 5) {
        isDragging = true;
        stageHistory[currentStage].placed = stageHistory[currentStage].placed.filter(p => p.id !== el.id);
        if (dock.contains(el)) {
          el.style.left = rect.left + "px"; el.style.top = rect.top + "px";
          el.style.position = "fixed"; document.body.appendChild(el);
        }
        el.classList.add("dragging");
        preview = document.createElement("div");
        preview.className = "preview";
        preview.style.width = w * cell + "px"; preview.style.height = h * cell + "px";
        board.appendChild(preview);
      }
      if (isDragging) {
        el.style.left = ev.clientX - dragOffsetX + "px";
        el.style.top = ev.clientY - dragOffsetY + "px";
        const br = board.getBoundingClientRect();
        const gx = Math.round((ev.clientX - br.left - dragOffsetX) / cell);
        const gy = Math.round((ev.clientY - br.top - dragOffsetY) / cell);
        preview.className = "preview " + (isValid(gx, gy, w, h) ? "ok" : "bad");
        preview.style.left = gx * cell + "px"; preview.style.top = gy * cell + "px";
      }
    };

    const onUp = ev => {
      document.removeEventListener("mousemove", onMove);
      document.removeEventListener("mouseup", onUp);
      const moveDist = Math.hypot(ev.clientX - startX, ev.clientY - startY);

      if (Date.now() - mouseDownTime < 250 && moveDist < 6) {
        const state = blockStates[el.id];
        const newW = state.h; const newH = state.w;
        const placedIdx = stageHistory[currentStage].placed.findIndex(p => p.id === el.id);
        if (placedIdx !== -1) {
          const p = stageHistory[currentStage].placed[placedIdx];
          const currentPlaced = stageHistory[currentStage].placed;
          stageHistory[currentStage].placed = currentPlaced.filter(item => item.id !== el.id);
          if (isValid(p.x, p.y, newW, newH)) {
            state.w = newW; state.h = newH;
            stageHistory[currentStage].placed.push({ ...p, w: newW, h: newH });
          } else { stageHistory[currentStage].placed = currentPlaced; }
        } else { state.w = newW; state.h = newH; }
      } else if (isDragging) {
        const br = board.getBoundingClientRect();
        const gx = Math.round((ev.clientX - br.left - dragOffsetX) / cell);
        const gy = Math.round((ev.clientY - br.top - dragOffsetY) / cell);
        if (isValid(gx, gy, w, h)) {
          stageHistory[currentStage].placed.push({ id: el.id, x: gx, y: gy, w, h });
          checkClear();
        }
      }
      preview?.remove(); el.remove(); refreshUI();
    };
    document.addEventListener("mousemove", onMove);
    document.addEventListener("mouseup", onUp);
  };
}

function isValid(x, y, w, h) {
  if (x < 0 || y < 0 || x + w > 8 || y + h > 8) return false;
  if (stages[currentStage].fixed.some(p => x < p.x + p.w && x + w > p.x && y < p.y + p.h && y + h > p.y)) return false;
  return !stageHistory[currentStage].placed.some(p => x < p.x + p.w && x + w > p.x && y < p.y + p.h && y + h > p.y);
}

function refreshUI() { renderBoard(); renderDock(); renderStages(); }

function startTimer() {
  clearInterval(timerInterval);
  startTime = Date.now();
  timerInterval = setInterval(() => {
    timerEl.textContent = `ì‹œê°„: ${((Date.now() - startTime) / 1000).toFixed(1)}s`;
  }, 100);
}

function checkClear() {
  if (stageHistory[currentStage].placed.length === movableBlocksInfo.length) {
    clearInterval(timerInterval);
    const t = ((Date.now() - startTime) / 1000).toFixed(1);
    clearedTime[currentStage] = t + "s";
    
    // ëª¨ë‹¬ í‘œì‹œ
    document.getElementById("clear-time-text").textContent = `ê¸°ë¡: ${t}ì´ˆ`;
    modal.style.display = "flex";
  }
}

function closeModal() {
  modal.style.display = "none";
  // ë‹¤ìŒ ë‹¨ê³„ë¡œ ì´ë™
  if (currentStage < 3) loadStage(currentStage + 1);
  else refreshUI();
}

function renderStages() {
  stagesEl.innerHTML = "";
  [1, 2, 3].forEach(i => {
    const b = document.createElement("button");
    b.className = "stage-btn" + (i === currentStage ? " active" : "") + (clearedTime[i] ? " cleared" : "");
    
    const nameSpan = document.createElement("span");
    nameSpan.textContent = i + "ë‹¨ê³„";
    b.appendChild(nameSpan);

    if (clearedTime[i]) {
      const timeSpan = document.createElement("span");
      timeSpan.className = "time-label";
      timeSpan.textContent = clearedTime[i];
      b.appendChild(timeSpan);
    }

    b.onclick = () => loadStage(i);
    stagesEl.appendChild(b);
  });
}

function loadStage(n) {
  currentStage = n;
  startTimer();
  refreshUI();
}

function resetCurrentStageOnly() {
  stageHistory[currentStage].placed = [];
  refreshUI();
}

// ì´ˆê¸°í™”
loadStage(1);
</script>

</body>
</html>