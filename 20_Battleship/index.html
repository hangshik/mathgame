<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <!-- viewport 설정에 viewport-fit=cover 추가 -->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
  <title>전함 퍼즐</title>
  <style>
    /* 
       [핵심 수정 1] 
       --cell-size를 vw(너비) 기준에서 vmin(너비와 높이 중 작은 쪽) 기준으로 변경 
       최대 크기도 65px -> 50px 정도로 줄여서 한 화면에 들어오도록 조정
    */
    :root { 
      --bg-color:#f8f9fa; 
      /* 화면이 좁거나 낮아도 비율을 유지하며 줄어들게 설정 */
      --cell-size: clamp(28px, 9vmin, 50px); 
    }

    body {
      font-family: 'Pretendard', sans-serif;
      background: var(--bg-color);
      display: flex;
      flex-direction: column;
      align-items: center;
      /* [핵심 수정 2] 높이 설정 및 패딩 조정 */
      min-height: 100dvh; /* 모바일 브라우저 동적 높이 대응 */
      padding: 10px 10px 40px 10px; /* 아래쪽 패딩을 늘려 버튼 공간 확보 */
      margin: 0;
      box-sizing: border-box;
      /* touch-action을 pan-y로 변경하여 게임판 밖에서는 스크롤 가능하게 함 */
      touch-action: pan-y; 
      overflow-x: hidden;
    }

    h2 { margin: 10px 0; font-size: 1.2rem; }

    .stage-container { display: flex; gap: 4px; margin-bottom: 8px; flex-wrap: wrap; justify-content: center; }
    .stage-btn {
      padding: 6px 10px; border: 2px solid #dee2e6; background: white; border-radius: 8px;
      cursor: pointer; font-size: 12px; font-weight: 800; transition: all 0.2s;
    }
    .stage-btn.active { background: #007bff; color: white; border-color: #007bff; }
    .stage-btn.cleared { background: #28a745; color: white; border-color: #28a745; }

    #status { min-height: 24px; margin: 4px 0 8px; font-weight: 900; font-size: 24px; color: #28a745; display: none; }

    /* 게임판과 독에는 터치 제스처(스크롤) 방지 */
    .grid-container {
      display: grid; grid-template-columns: repeat(6, var(--cell-size)); gap: 4px;
      background: #c9d0d6; padding: 8px; border-radius: 12px; position: relative;
      touch-action: none; /* 게임판 내부 스크롤 방지 */
    }
    .cell {
      width: var(--cell-size); height: var(--cell-size); background: white; border-radius: 6px;
      display: flex; align-items: center; justify-content: center; position: relative;
      font-size: calc(var(--cell-size) * 0.5); /* 폰트 크기도 셀 크기에 비례 */
    }
    .cell.hint { background: none; font-weight: 900; color: #495057; }
    .cell.hint.correct { color: #28a745; text-shadow: 1px 1px 0px white; }
    .cell.hint.over { color: #dc3545; text-shadow: 1px 1px 0px white; }
    .cell.preview { background: rgba(0,123,255,0.22)!important; border: 2px solid #007bff; box-sizing: border-box; }

    .ship {
      position: absolute; display: flex; border-radius: 8px; cursor: grab;
      box-shadow: 0 3px 10px rgba(0,0,0,0.2);
      z-index: 50; touch-action: none; left: 0; top: 0;
      user-select: none; -webkit-user-select: none;
    }
    .ship-part {
      flex: 1; display: flex; align-items: center; justify-content: center;
      color: white; font-weight: 900; 
      font-size: calc(var(--cell-size) * 0.6); /* 배 숫자 크기 조절 */
      pointer-events: none;
    }
    .ship.horizontal { height: var(--cell-size); }
    .ship.vertical { width: var(--cell-size); flex-direction: column; }

    .drag-clone {
      position: fixed !important; left: 0; top: 0; z-index: 99999;
      pointer-events: none; opacity: 0.92; cursor: grabbing;
      will-change: transform;
    }

    .dock {
      display: flex; gap: 10px; padding: 15px; background: white; border-radius: 15px;
      margin-top: 10px; min-height: var(--cell-size); width: 95%; max-width: 550px;
      border: 2px dashed #dee2e6; justify-content: center; align-items: center;
      box-sizing: border-box;
      touch-action: none; /* 독 내부 스크롤 방지 */
    }
    
    .controls { margin-top: 10px; display: flex; gap: 10px; margin-bottom: 20px; }
    button.action-btn { 
        padding: 12px 20px; border-radius: 12px; border: none; cursor: pointer; 
        font-weight: 900; font-size: 0.9rem; 
        /* 모바일 터치 영역 확보 */
        min-width: 80px; 
    }
    
    button.hint-btn { background: #ffc107; color: #212529; transition: background 0.3s; }
    button.hint-btn:disabled { background: #adb5bd; color: #6c757d; cursor: not-allowed; border: 1px solid #ced4da; }
  </style>
</head>
<body>
<h2>전함 퍼즐</h2>

  <div class="stage-container" id="stageButtons"></div>
  <div id="status">성공입니다.</div>
  <div id="grid" class="grid-container"></div>
  <div id="dock" class="dock"></div>

  <div class="controls">
    <button id="btnHint" class="action-btn hint-btn" onclick="useHint()">힌트</button>
    <button class="action-btn" style="background:#007bff;color:white;" onclick="resetCurrentStage()">초기화</button>
  </div>
  
    <a href="example.html" style="
    display: block;
    width: 250px;
    padding: 20px;
    border: 1px solid #333;
    border-radius: 12px;
    background-color: #ffffff;
    text-align: center;
    font-family: sans-serif;
    font-size: 20px;
    margin: 30px auto;
    text-decoration: none;
    color: #000;
  ">
    문제 설명
  </a>
  <!-- <br> 태그 제거됨 -->

<script>
  // 스크립트 내용은 기존과 동일합니다.
  const SIZE = 5;
  const MAX_HINTS = 4;

  let currentStage = 1;
  let allStagesData = {};
  let clearedStages = {};
  
  let stageHintStatus = {};
  let solutionCache = {};

  const shipColors = ['', '#fcc419', '#51cf66', '#4dabf7', '#ff6b6b', '#cc5de8'];

  const stageHints = {
    1:  { rSums: [0, 0, 0, 3, 6],  cSums: [2, 3, 4, 5, 0] },
    2:  { rSums: [1, 5, 7, 6, 0],  cSums: [2, 6, 0, 0, 9] },
    3:  { rSums: [3, 0, 0, 0, 7],  cSums: [7, 2, 0, 0, 7] },
    4:  { rSums: [0, 9, 4, 3, 0],  cSums: [10, 0, 11, 0, 5] },
    5:  { rSums: [8, 0, 0, 0, 7],  cSums: [0, 3, 4, 5, 6] },
    6:  { rSums: [5, 7, 0, 0, 0],  cSums: [4, 0, 4, 5, 5] },
    7:  { rSums: [6, 7, 0, 6, 7],  cSums: [0, 5, 0, 8, 5] },
    8:  { rSums: [7, 0, 10, 0, 2], cSums: [0, 8, 0, 10, 3] },
    9:  { rSums: [0, 0, 3, 5, 5],  cSums: [0, 0, 13, 11, 5] },
    10: { rSums: [3, 3, 5, 0, 0],  cSums: [6, 9, 0, 0, 6] },
    11: { rSums: [10, 0, 0, 3, 0], cSums: [0, 8, 0, 10, 6] },
  };

  let dockDir = {1:'h',2:'h',3:'h',4:'h',5:'h'};

  function init(){
    for(let i=1;i<=11;i++){
      allStagesData[i]=[];
      stageHintStatus[i] = { count: 0, revealedIds: new Set() };
    }
    renderStageButtons();
    loadStage(1);
  }

  function renderStageButtons(){
    const container=document.getElementById('stageButtons');
    container.innerHTML='';
    for(let i=1;i<=11;i++){
      const btn=document.createElement('button');
      const count = stageHintStatus[i].count;
      const hintText = count > 0 ? `(${count})` : '';
      btn.className=`stage-btn ${i===currentStage?'active':''} ${clearedStages[i]?'cleared':''}`;
      btn.innerText = i + "단계" + hintText;
      btn.onclick=()=>loadStage(i);
      container.appendChild(btn);
    }
  }

  function findNextHintTarget(stageNum) {
    const solution = getSolution(stageNum);
    if (!solution || solution.length === 0) return null;

    let currentShips = allStagesData[stageNum];
    const sortedSol = [...solution].sort((a,b) => b.id - a.id);

    for (let solShip of sortedSol) {
      const placed = currentShips.find(s => s.id === solShip.id);
      if (!placed || placed.r !== solShip.r || placed.c !== solShip.c || placed.dir !== solShip.dir) {
        return solShip;
      }
    }
    return null; 
  }

  function updateHintButtonUI() {
    const btn = document.getElementById('btnHint');
    const status = stageHintStatus[currentStage];
    
    if (clearedStages[currentStage]) {
      btn.disabled = true;
      btn.innerText = "성공";
      return;
    }

    const targetShip = findNextHintTarget(currentStage);
    let canUse = false;
    if (targetShip) {
      if (status.count < MAX_HINTS) {
        canUse = true;
      }
      else if (targetShip.id >= 2 || status.revealedIds.has(targetShip.id)) {
        canUse = true;
      }
    }

    if (canUse) {
      btn.disabled = false;
      btn.innerText = "힌트";
    } else {
      btn.disabled = true;
      btn.innerText = status.count >= MAX_HINTS ? "힌트 끝" : "힌트";
    }
  }

  function setStatus(ok){
    const el = document.getElementById('status');
    el.style.display = ok ? 'block' : 'none';
    el.textContent = ok ? '성공입니다.' : '';
  }

  function computeSumsUnified(ships){
    let curR=[0,0,0,0,0], curC=[0,0,0,0,0];
    ships.forEach(s=>{
      if(s.dir === 'h'){
        if(s.r>=0 && s.r<SIZE) curR[s.r] += s.id;
        for(let i=0;i<3;i++){
          const cc = s.c + i;
          if(cc>=0 && cc<SIZE) curC[cc] += s.id;
        }
      } else {
        if(s.c>=0 && s.c<SIZE) curC[s.c] += s.id;
        for(let i=0;i<3;i++){
          const rr = s.r + i;
          if(rr>=0 && rr<SIZE) curR[rr] += s.id;
        }
      }
    });
    return {curR, curC};
  }

  function checkWinAndUpdateUI(){
    const hints = stageHints[currentStage];
    const ships = allStagesData[currentStage];
    const {curR, curC} = computeSumsUnified(ships);

    const rowOk = curR.every((v,i)=>{
      const h = hints.rSums[i];
      if(h === 0) return true;
      return v === h;
    });
    const colOk = curC.every((v,i)=>{
      const h = hints.cSums[i];
      if(h === 0) return true;
      return v === h;
    });

    const win = ships.length===5 && rowOk && colOk;
    setStatus(win);
    if(win) {
      clearedStages[currentStage] = true;
      renderStageButtons();
      updateHintButtonUI();
    }
    return win;
  }

  function loadStage(n){
    currentStage=n;
    setStatus(false);
    dockDir = {1:'h',2:'h',3:'h',4:'h',5:'h'};
    renderStageButtons();
    renderBoard();
    renderDock();
    updateHintButtonUI();
  }

  function getSolution(stageNum) {
    if (solutionCache[stageNum]) return solutionCache[stageNum];
    const shipsToPlace = [5, 4, 3, 2, 1];
    const hints = stageHints[stageNum];
    let result = null;

    function solve(idx, currentShips) {
      if (result) return;
      if (idx >= shipsToPlace.length) {
        const {curR, curC} = computeSumsUnified(currentShips);
        const rowOk = curR.every((v,i) => hints.rSums[i] === 0 || v === hints.rSums[i]);
        const colOk = curC.every((v,i) => hints.cSums[i] === 0 || v === hints.cSums[i]);
        if (rowOk && colOk) result = JSON.parse(JSON.stringify(currentShips));
        return;
      }
      const shipId = shipsToPlace[idx];
      const {curR, curC} = computeSumsUnified(currentShips);
      for(let i=0; i<SIZE; i++) {
        if(hints.rSums[i] !== 0 && curR[i] > hints.rSums[i]) return;
        if(hints.cSums[i] !== 0 && curC[i] > hints.cSums[i]) return;
      }
      for (let r = 0; r < SIZE; r++) {
        for (let c = 0; c < SIZE; c++) {
          for (let dir of ['h', 'v']) {
            if (isValidPlacement(r, c, dir, shipId, currentShips)) {
              currentShips.push({id: shipId, r, c, dir});
              solve(idx + 1, currentShips);
              if (result) return;
              currentShips.pop();
            }
          }
        }
      }
    }

    function isValidPlacement(r, c, dir, id, placedShips) {
      for(let i=0; i<3; i++) {
        const rr = dir==='h'?r:r+i;
        const cc = dir==='h'?c+i:c;
        if(rr<0 || cc<0 || rr>=SIZE || cc>=SIZE) return false;
        for (let s of placedShips) {
            for(let j=0; j<3; j++) {
                const sr = s.dir==='h'?s.r:s.r+j;
                const sc = s.dir==='h'?s.c+j:s.c;
                if(sr===rr && sc===cc) return false;
            }
        }
      }
      return true;
    }

    solve(0, []);
    if (result) {
      solutionCache[stageNum] = result;
      return result;
    }
    return [];
  }

  function useHint() {
    if (clearedStages[currentStage]) return;

    const targetShip = findNextHintTarget(currentStage);
    const status = stageHintStatus[currentStage];

    if (!targetShip) return;

    if (status.count >= MAX_HINTS) {
      const isLargeShip = targetShip.id >= 2;
      const isRevealed = status.revealedIds.has(targetShip.id);
      if (!isLargeShip && !isRevealed) {
        return;
      }
    }

    allStagesData[currentStage] = allStagesData[currentStage].filter(s => s.id !== targetShip.id);
    allStagesData[currentStage].push({...targetShip});
    
    if (!status.revealedIds.has(targetShip.id)) {
      status.revealedIds.add(targetShip.id);
      if (status.count < MAX_HINTS) {
        status.count++;
      }
    }
    
    renderStageButtons();
    renderBoard();
    renderDock();
    updateHintButtonUI();
  }

  function renderBoard(){
    const grid=document.getElementById('grid');
    grid.innerHTML='';
    const hints=stageHints[currentStage];
    const ships=allStagesData[currentStage];
    const {curR, curC} = computeSumsUnified(ships);

    for(let r=0;r<=SIZE;r++){
      for(let c=0;c<=SIZE;c++){
        const cell=document.createElement('div');
        if(r<SIZE && c<SIZE){
          cell.className='cell';
          cell.dataset.r=r; cell.dataset.c=c;
        } else {
          cell.className='cell hint';
          if(r<SIZE && c===SIZE){
            const hint=hints.rSums[r];
            if(hint===0){
              cell.innerText='';
            } else {
              cell.innerText=hint;
              if(curR[r] === hint) cell.classList.add('correct');
              else if(curR[r] > hint) cell.classList.add('over');
            }
          } else if(r===SIZE && c<SIZE){
            const hint=hints.cSums[c];
            if(hint===0){
              cell.innerText='';
            } else {
              cell.innerText=hint;
              if(curC[c] === hint) cell.classList.add('correct');
              else if(curC[c] > hint) cell.classList.add('over');
            }
          }
        }
        grid.appendChild(cell);
      }
    }
    ships.forEach(s=>drawShip(s,false));
    checkWinAndUpdateUI();
  }

  function renderDock(){
    const dock=document.getElementById('dock');
    dock.innerHTML='';
    const ships=allStagesData[currentStage];
    const placedIds=ships.map(s=>s.id);
    for(let i=1;i<=5;i++){
      if(!placedIds.includes(i)){
        drawShip({id:i,dir:(dockDir[i]||'h'),r:-1,c:-1},true);
      }
    }
  }

  function drawShip(s,inDock){
    const ship=document.createElement('div');
    const dir=s.dir||'h';
    ship.className=`ship ${dir==='h'?'horizontal':'vertical'}`;
    ship.style.backgroundColor=shipColors[s.id];
    ship.dataset.id=s.id;
    ship.dataset.dir=dir;

    const sizeUnit=`var(--cell-size)`;
    if(dir==='h'){
      ship.style.width=`calc(${sizeUnit} * 3 + 12px)`;
      ship.style.height=sizeUnit;
    } else {
      ship.style.width=sizeUnit;
      ship.style.height=`calc(${sizeUnit} * 3 + 12px)`;
    }

    for(let i=0;i<3;i++){
      const part=document.createElement('div');
      part.className='ship-part';
      if(i===1) part.innerText=s.id;
      ship.appendChild(part);
    }

    if(inDock){
      ship.style.position='relative';
      ship.style.left='0px'; ship.style.top='0px';
      document.getElementById('dock').appendChild(ship);
    } else {
      const cell=document.querySelector(`.cell[data-r="${s.r}"][data-c="${s.c}"]`);
      if(cell) {
        cell.appendChild(ship);
        ship.style.left='0px'; ship.style.top='0px';
      }
    }

    bindDragWithCenterPlacement(ship, s.id);
  }

  function getTargetCell(x,y){
    const cells=document.querySelectorAll('.cell[data-r]');
    for(const cell of cells){
      const rect=cell.getBoundingClientRect();
      if(x>=rect.left && x<=rect.right && y>=rect.top && y<=rect.bottom){
        return { r:parseInt(cell.dataset.r), c:parseInt(cell.dataset.c) };
      }
    }
    return null;
  }

  function getAnchorFromPointerCell(pointerCell, dir){
    if(!pointerCell) return null;
    if(dir === 'h') return { r: pointerCell.r, c: pointerCell.c - 1 };
    return { r: pointerCell.r - 1, c: pointerCell.c };
  }

  function updatePreview(x,y,dir,id){
    clearPreview();
    const pointerCell = getTargetCell(x,y);
    const anchor = getAnchorFromPointerCell(pointerCell, dir);
    if(anchor && canPlace(anchor.r, anchor.c, dir, id)){
      for(let i=0;i<3;i++){
        const rr = dir==='h'?anchor.r:anchor.r+i;
        const cc = dir==='h'?anchor.c+i:anchor.c;
        const cEl=document.querySelector(`.cell[data-r="${rr}"][data-c="${cc}"]`);
        if(cEl) cEl.classList.add('preview');
      }
    }
  }

  function clearPreview(){
    document.querySelectorAll('.cell').forEach(c=>c.classList.remove('preview'));
  }

  function canPlace(r,c,dir,id){
    for(let i=0;i<3;i++){
      const rr=dir==='h'?r:r+i;
      const cc=dir==='h'?c+i:c;
      if(rr<0 || cc<0 || rr>=SIZE || cc>=SIZE) return false;
      if(allStagesData[currentStage].some(s=>s.id!==id && isOverlapping(s,rr,cc))) return false;
    }
    return true;
  }

  function isOverlapping(s,rr,cc){
    for(let i=0;i<3;i++){
      const sr=s.dir==='h'?s.r:s.r+i;
      const sc=s.dir==='h'?s.c+i:s.c;
      if(sr===rr && sc===cc) return true;
    }
    return false;
  }

  function placeShip(id,r,c,dir){
    allStagesData[currentStage]=allStagesData[currentStage].filter(s=>s.id!==id);
    allStagesData[currentStage].push({id,r,c,dir});
    renderBoard(); renderDock();
  }

  function rotateShip(id){
    const ships=allStagesData[currentStage];
    const s=ships.find(ss=>ss.id===id);
    if(s){
      const oldDir = s.dir;
      const nextDir = oldDir === 'h' ? 'v' : 'h';
      const centerR = (oldDir === 'h') ? s.r : (s.r + 1);
      const centerC = (oldDir === 'h') ? (s.c + 1) : s.c;
      const newR = (nextDir === 'h') ? centerR : (centerR - 1);
      const newC = (nextDir === 'h') ? (centerC - 1) : centerC;
      if(canPlace(newR, newC, nextDir, id)){
        s.r = newR; s.c = newC; s.dir = nextDir;
      }
      renderBoard(); renderDock();
    } else {
      dockDir[id] = (dockDir[id] === 'h') ? 'v' : 'h';
      renderDock();
    }
  }

  function bindDragWithCenterPlacement(el, id){
    let startX=0, startY=0;
    let clone=null;
    let dragging=false;
    const DRAG_START_THRESHOLD=7;

    const onPointerDown = (e) => {
      e.stopPropagation();
      e.preventDefault();
      
      startX=e.clientX; 
      startY=e.clientY;
      dragging=false;

      document.addEventListener('pointermove', onPointerMove);
      document.addEventListener('pointerup', onPointerUp);
      document.addEventListener('pointercancel', onPointerUp);
    };

    const onPointerMove = (e) => {
      const dx=e.clientX-startX, dy=e.clientY-startY;
      
      if(!dragging && Math.hypot(dx,dy) < DRAG_START_THRESHOLD) return;

      if(!dragging){
        dragging=true;
        clone = el.cloneNode(true);
        clone.classList.add('drag-clone');
        document.body.appendChild(clone);
        el.style.visibility='hidden';
      }

      if(clone){
        clone.style.transform = `translate3d(${e.clientX}px, ${e.clientY}px, 0) translate(-50%, -50%)`;
        updatePreview(e.clientX, e.clientY, clone.dataset.dir, id);
      }
    };

    const onPointerUp = (e) => {
      document.removeEventListener('pointermove', onPointerMove);
      document.removeEventListener('pointerup', onPointerUp);
      document.removeEventListener('pointercancel', onPointerUp);

      clearPreview();

      if(!dragging){
        rotateShip(id);
        return;
      }

      if(clone){ 
        clone.remove(); 
        clone=null; 
      }
      el.style.visibility='';

      const pointerCell = getTargetCell(e.clientX, e.clientY);
      const dir = el.dataset.dir;
      const anchor = getAnchorFromPointerCell(pointerCell, dir);

      if(anchor && canPlace(anchor.r, anchor.c, dir, id)){
        placeShip(id, anchor.r, anchor.c, dir);
      } else {
        allStagesData[currentStage] = allStagesData[currentStage].filter(s=>s.id!==id);
        renderBoard(); renderDock();
      }
    };

    el.addEventListener('pointerdown', onPointerDown);
  }

  function resetCurrentStage(){
    allStagesData[currentStage]=[];
    setStatus(false);
    dockDir = {1:'h',2:'h',3:'h',4:'h',5:'h'};
    renderStageButtons();
    renderBoard(); 
    renderDock();
    updateHintButtonUI(); 
  }

  init();
</script>
</body>
</html>
