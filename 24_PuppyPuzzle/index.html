<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ê°•ì•„ì§€ í¼ì¦ - í”„ë¡œ ì—ë””ì…˜ (ì—°ì† ì´ë™ ìˆ˜ì •ë³¸)</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f0f2f5;
      margin: 0;
      padding: 20px;
      color: #333;
      overscroll-behavior: none;
      touch-action: none; 
    }
    .status-bar { display: flex; gap: 20px; margin-bottom: 15px; }
    .info-box {
      font-weight: 600; font-size: 18px; background: white;
      padding: 8px 16px; border-radius: 12px; box-shadow: 0 2px 5px rgba(0,0,0,0.05);
    }
    .puzzle-container {
      position: relative; border: 8px solid #343a40; border-radius: 12px;
      background-color: #e9ecef; width: 348px; height: 290px; 
      box-shadow: 0 10px 25px rgba(0,0,0,0.2); touch-action: none; 
      user-select: none; -webkit-user-select: none; overflow: hidden;
    }
    .puzzle-container::before {
      content: ""; position: absolute; top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      background-image: 
        linear-gradient(to right, #dee2e6 1px, transparent 1px),
        linear-gradient(to bottom, #dee2e6 1px, transparent 1px);
      background-size: 58px 58px;
    }
    .target-guide {
      position: absolute; width: 54px; height: 54px; border: 3px dashed;
      border-radius: 8px; opacity: 0.3; z-index: 0; box-sizing: border-box;
    }
    .block {
      position: absolute; z-index: 1; cursor: grab;
      filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.15));
      touch-action: none; transition: left 0.1s ease-out, top 0.1s ease-out;
    }
    .block.dragging { z-index: 100; cursor: grabbing; transition: none; }
    .cell { position: absolute; width: 58px; height: 58px; box-sizing: border-box; }
    .red .cell { background-color: #ff4f4f; border: 2px solid #c92a2a; border-radius: 8px; }
    .blue .cell { background-color: #339af0; border: 2px solid #1864ab; border-radius: 8px; }
    .green1 .cell { background-color: #51cf66; border: 2px solid #2b8a3e; border-radius: 8px; }
    .green2 .cell { background-color: #2b8a3e; border: 2px solid #1b4332; border-radius: 8px; }
    .yellow .cell { background-color: #fcc419; border: 2px solid #e67700; border-radius: 6px; }
    .fixed .cell { background-color: #495057; border: 2px solid #212529; border-radius: 6px; }

    .modal-overlay {
      position: fixed; top: 0; left: 0; width: 100%; height: 100%;
      background: rgba(0, 0, 0, 0.4); backdrop-filter: blur(8px);
      display: none; justify-content: center; align-items: center; z-index: 1000;
    }
    .modal-content {
      background: white; padding: 30px; border-radius: 24px; text-align: center;
      box-shadow: 0 20px 40px rgba(0,0,0,0.2); max-width: 80%;
    }
    .controls { margin-top: 24px; display: flex; gap: 12px; }
    .btn {
      font-size: 16px; padding: 14px 28px; border: none; border-radius: 12px;
      cursor: pointer; background-color: #339af0; color: white;
      font-weight: 600; transition: 0.2s; box-shadow: 0 4px 0 #1c7ed6;
    }
    .btn:active { transform: translateY(2px); box-shadow: none; }
    .btn-secondary { background-color: #adb5bd; box-shadow: 0 4px 0 #868e96; }
    .btn-success { background-color: #40c057; box-shadow: 0 4px 0 #2b8a3e; margin-top: 10px; }
  </style>
</head>
<body>

  <h1>ê°•ì•„ì§€ í¼ì¦</h1>
  
  <div class="status-bar">
    <div class="info-box">ì´ë™: <span id="moveCount">0</span></div>
    <div class="info-box">ì‹œê°„: <span id="timerDisplay">00:00</span></div>
  </div>
  
  <div class="puzzle-container" id="puzzle"></div>

  <div class="controls">
    <button class="btn btn-secondary" onclick="undoMove()">ë˜ëŒë¦¬ê¸°</button>
    <button class="btn" onclick="resetPuzzle()">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <div class="modal-overlay" id="successModal">
    <div class="modal-content">
      <h2>ğŸ‰ ë¯¸ì…˜ ì„±ê³µ!</h2>
      <div class="modal-stats">
        <p>ì´ë™ íšŸìˆ˜: <strong id="finalMoves">0</strong>íšŒ</p>
        <p>ì†Œìš” ì‹œê°„: <strong id="finalTime">00:00</strong></p>
      </div>
      <button class="btn btn-success" onclick="closeModal()">í™•ì¸</button>
    </div>
  </div>

  <script>
    const puzzle = document.getElementById("puzzle");
    const moveCountEl = document.getElementById("moveCount");
    const timerEl = document.getElementById("timerDisplay");
    const successModal = document.getElementById("successModal");
    
    const cellSize = 58; 
    const gridCols = 6;
    const gridRows = 5;

    let blocks = [];
    let moveCount = 0;
    let history = [];
    let timerInterval = null;
    let seconds = 0;
    let gameStarted = false;

    const initialBlocks = [
      { id: "red", color: "red", x: 3, y: 3, shape: [{dx:0, dy:0}] },
      { id: "blue", color: "blue", x: 5, y: 3, shape: [{dx:0, dy:0}] },
      { id: "green1", color: "green1", x: 3, y: 0, shape: [{dx:0, dy:0}] },
      { id: "green2", color: "green2", x: 4, y: 0, shape: [{dx:0, dy:0}, {dx:1, dy:0}] },
      { id: "yellow", color: "yellow", x: 1, y: 1, shape: [[1,1,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[1,1,0,1,1]].flatMap((row,y)=>row.map((v,x)=>v?{dx:x,dy:y}:null).filter(v=>v)) },
      { id: "f1", color: "fixed", x: 0, y: 2, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f2", color: "fixed", x: 5, y: 1, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f3", color: "fixed", x: 3, y: 4, shape: [{dx:0, dy:0}], fixed: true }
    ];

    const startPos = { red: { x: 3, y: 3 }, blue: { x: 5, y: 3 } };

    function initPuzzle() {
      puzzle.innerHTML = "";
      
      // ê°€ì´ë“œ ìƒì„±
      const createGuide = (x, y, color) => {
        const g = document.createElement("div");
        g.className = "target-guide";
        g.style.left = `${x * cellSize + 2}px`;
        g.style.top = `${y * cellSize + 2}px`;
        g.style.borderColor = color;
        puzzle.appendChild(g);
      };
      createGuide(startPos.blue.x, startPos.blue.y, "#ff4f4f");
      createGuide(startPos.red.x, startPos.red.y, "#339af0");

      // ë¸”ë¡ ìš”ì†Œ ìƒì„±
      blocks.forEach(block => {
        const blockDiv = document.createElement("div");
        blockDiv.className = `block ${block.color}`;
        blockDiv.id = `block-${block.id}`;
        block.el = blockDiv; // DOM ì°¸ì¡° ì €ì¥

        block.shape.forEach(pos => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.style.left = `${pos.dx * cellSize}px`;
          cell.style.top = `${pos.dy * cellSize}px`;
          blockDiv.appendChild(cell);
        });

        if (!block.fixed) addDragEvents(blockDiv, block);
        puzzle.appendChild(blockDiv);
      });
      updateBlockStyles();
    }

    // ìŠ¤íƒ€ì¼ë§Œ ì—…ë°ì´íŠ¸í•˜ì—¬ ëŠê¹€ ë°©ì§€
    function updateBlockStyles() {
      blocks.forEach(block => {
        block.el.style.left = `${block.x * cellSize}px`;
        block.el.style.top = `${block.y * cellSize}px`;
      });
    }

    function getPushChain(block, dx, dy, chain) {
      if (block.fixed) return false;
      if (chain.has(block)) return true;
      chain.add(block);

      for (let p of block.shape) {
        const nx = block.x + p.dx + dx;
        const ny = block.y + p.dy + dy;
        if (nx < 0 || nx >= gridCols || ny < 0 || ny >= gridRows) return false;
        
        for (let other of blocks) {
          if (chain.has(other)) continue;
          for (let op of other.shape) {
            if (nx === other.x + op.dx && ny === other.y + op.dy) {
              if (!getPushChain(other, dx, dy, chain)) return false;
            }
          }
        }
      }
      return true;
    }

    function addDragEvents(el, block) {
      let startX, startY;
      let isDragging = false;
      let movedInThisDrag = false;

      const onStart = (e) => {
        startTimer();
        el.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        isDragging = true;
        movedInThisDrag = false;
        el.classList.add('dragging');
      };

      const onMove = (e) => {
        if (!isDragging) return;

        let distX = e.clientX - startX;
        let distY = e.clientY - startY;

        // Xì¶• ì—°ì† ì´ë™
        while (Math.abs(distX) >= cellSize) {
          let dx = distX > 0 ? 1 : -1;
          let chain = new Set();
          if (getPushChain(block, dx, 0, chain)) {
            chain.forEach(b => { b.x += dx; });
            startX += dx * cellSize;
            distX = e.clientX - startX;
            movedInThisDrag = true;
          } else { break; }
        }

        // Yì¶• ì—°ì† ì´ë™
        while (Math.abs(distY) >= cellSize) {
          let dy = distY > 0 ? 1 : -1;
          let chain = new Set();
          if (getPushChain(block, 0, dy, chain)) {
            chain.forEach(b => { b.y += dy; });
            startY += dy * cellSize;
            distY = e.clientY - startY;
            movedInThisDrag = true;
          } else { break; }
        }

        if (movedInThisDrag) {
          updateBlockStyles();
        }
      };

      const onEnd = (e) => {
        if (!isDragging) return;
        isDragging = false;
        el.releasePointerCapture(e.pointerId);
        el.classList.remove('dragging');

        if (movedInThisDrag) {
          saveHistory(); 
          moveCount++; 
          updateMoveCount();
          checkWin();
        }
      };

      el.addEventListener("pointerdown", onStart);
      el.addEventListener("pointermove", onMove);
      el.addEventListener("pointerup", onEnd);
      el.addEventListener("pointercancel", onEnd);
    }

    // íƒ€ì´ë¨¸ ë° ê¸°íƒ€ ê¸°ëŠ¥ë“¤
    function startTimer() {
      if (gameStarted) return;
      gameStarted = true;
      timerInterval = setInterval(() => {
        seconds++;
        const m = String(Math.floor(seconds / 60)).padStart(2, '0');
        const s = String(seconds % 60).padStart(2, '0');
        timerEl.textContent = `${m}:${s}`;
      }, 1000);
    }
    function stopTimer() { clearInterval(timerInterval); }
    function checkWin() {
      const red = blocks.find(b => b.id === "red");
      const blue = blocks.find(b => b.id === "blue");
      if (red.x === startPos.blue.x && red.y === startPos.blue.y &&
          blue.x === startPos.red.x && blue.y === startPos.red.y) {
        stopTimer();
        document.getElementById("finalMoves").textContent = moveCount;
        document.getElementById("finalTime").textContent = timerEl.textContent;
        successModal.style.display = "flex";
      }
    }
    function closeModal() { successModal.style.display = "none"; resetPuzzle(); }
    function saveHistory() {
      const snapshot = blocks.map(b => ({ id: b.id, x: b.x, y: b.y }));
      history.push(snapshot);
      if (history.length > 100) history.shift();
    }
    function undoMove() {
      if (history.length <= 1) return;
      history.pop();
      const lastState = history[history.length - 1];
      lastState.forEach(saved => {
        const block = blocks.find(b => b.id === saved.id);
        block.x = saved.x; block.y = saved.y;
      });
      moveCount++; updateMoveCount(); updateBlockStyles();
    }
    function updateMoveCount() { moveCountEl.textContent = moveCount; }
    function resetPuzzle() {
      stopTimer(); seconds = 0; gameStarted = false;
      timerEl.textContent = "00:00";
      blocks = JSON.parse(JSON.stringify(initialBlocks));
      history = [];
      saveHistory();
      moveCount = 0;
      updateMoveCount();
      initPuzzle();
    }

    resetPuzzle();
  </script>
</body>
</html>