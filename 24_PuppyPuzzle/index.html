<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>ëŸ¬ì‹œì•„ì›Œ - ìœ„ì¹˜ êµí™˜ & í‘¸ì‹œ (í™•ëŒ€ ë²„ì „)</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f8f9fa;
      margin: 0;
      padding: 40px;
      color: #333;
    }

    .move-counter {
      margin: 18px 0;
      font-weight: 600;
      font-size: 24px;
      color: #495057;
    }

    .puzzle-container {
      display: grid;
      /* 48px * 1.5 = 72px */
      grid-template-columns: repeat(6, 72px);
      grid-template-rows: repeat(5, 72px); 
      position: relative;
      border: 12px solid #343a40;
      border-radius: 12px;
      background-color: #e9ecef;
      width: 432px; /* 72 * 6 */
      height: 360px; /* 72 * 5 */
      box-shadow: 0 10px 25px rgba(0,0,0,0.2);
    }
    
    /* ë°°ê²½ ê²©ì */
    .puzzle-container::before {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      background-image: 
        linear-gradient(to right, #dee2e6 2px, transparent 2px),
        linear-gradient(to bottom, #dee2e6 2px, transparent 2px);
      background-size: 72px 72px;
    }

    .target-guide {
      position: absolute;
      width: 68px; /* 72 - 4 */
      height: 68px;
      border: 4px dashed;
      border-radius: 10px;
      opacity: 0.4;
      z-index: 0;
      box-sizing: border-box;
    }

    .block {
      position: absolute;
      z-index: 1;
      transition: all 0.1s ease-out;
      cursor: grab;
      /* ë¸”ë¡ ì „ì²´ì— ë“œë¡­ ì„€ë„ìš°ë¥¼ ì£¼ì–´ ì…ì²´ê° ë¶€ì—¬ */
      filter: drop-shadow(2px 4px 6px rgba(0,0,0,0.2));
    }
    .block:active { cursor: grabbing; z-index: 100; }

    .cell {
      position: absolute;
      width: 72px;
      height: 72px;
      box-sizing: border-box;
      /* ì…€ ê°„ì˜ ê²½ê³„ë¥¼ ì—†ì• ê¸° ìœ„í•´ í…Œë‘ë¦¬ ëŒ€ì‹  ì•ˆìª½ ê·¸ë¦¼ì ì‚¬ìš© */
      border: 0.5px solid rgba(0,0,0,0.1); 
    }

    /* ê° ìƒ‰ìƒë³„ ìŠ¤íƒ€ì¼: í•˜ë‚˜ì˜ ë©ì–´ë¦¬ì²˜ëŸ¼ ë³´ì´ê²Œ ë°°ê²½ìƒ‰ í†µì¼ */
    .red .cell { background-color: #ff4f4f; border: 2px solid #c92a2a; border-radius: 8px; }
    .blue .cell { background-color: #339af0; border: 2px solid #1864ab; border-radius: 8px; }
    .green1 .cell { background-color: #51cf66; border: 2px solid #2b8a3e; border-radius: 8px; }
    .green2 .cell { background-color: #2b8a3e; border: 2px solid #1b4332; border-radius: 8px; }
    .yellow .cell { background-color: #fcc419; border: 1px solid #e67700; }
    .fixed .cell { background-color: #343a40; border: 2px solid #000; border-radius: 4px; }

    /* ë…¸ë€ìƒ‰ì²˜ëŸ¼ ë³µì¡í•œ ë¸”ë¡ì˜ ëª¨ì„œë¦¬ ì²˜ë¦¬ë¥¼ ìœ„í•œ ì„¤ì • (ì„ íƒ ì‚¬í•­) */
    .yellow .cell { border-radius: 4px; }

    #success {
      margin-top: 24px;
      font-size: 28px;
      color: #40c057;
      font-weight: 800;
      display: none;
      text-align: center;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.1);
    }

    .controls { margin-top: 30px; display: flex; gap: 15px; }
    .btn {
      font-size: 18px; padding: 12px 24px; border: none; border-radius: 8px;
      cursor: pointer; background-color: #339af0; color: white;
      font-weight: 600; transition: 0.2s;
      box-shadow: 0 4px 0 #1c7ed6;
    }
    .btn:hover { background-color: #1c7ed6; transform: translateY(-2px); }
    .btn:active { transform: translateY(2px); box-shadow: none; }
    .btn-secondary { background-color: #adb5bd; box-shadow: 0 4px 0 #868e96; }
    .btn-secondary:hover { background-color: #868e96; }
  </style>
</head>
<body>
  <h2>ë¹¨ê°• â†” íŒŒë‘ ìŠ¤ì™€í”„ ë¯¸ì…˜ (1.5x)</h2>
  <div class="move-counter">ì´ë™ íšŸìˆ˜: <span id="moveCount">0</span></div>
  
  <div class="puzzle-container" id="puzzle"></div>
  <div id="success">ğŸ‰ ë¯¸ì…˜ ì„±ê³µ! ìë¦¬ë¥¼ ë°”ê¿¨ìŠµë‹ˆë‹¤!</div>

  <div class="controls">
    <button class="btn btn-secondary" onclick="undoMove()">ë˜ëŒë¦¬ê¸°</button>
    <button class="btn" onclick="resetPuzzle()">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <script>
    const puzzle = document.getElementById("puzzle");
    const moveCountEl = document.getElementById("moveCount");
    const successEl = document.getElementById("success");
    const cellSize = 72; // 48 * 1.5
    const gridCols = 6;
    const gridRows = 5;

    let blocks = [];
    let moveCount = 0;
    let history = [];

    const initialBlocks = [
      { id: "red", color: "red", x: 3, y: 3, shape: [{dx:0, dy:0}], fixed: false },
      { id: "blue", color: "blue", x: 5, y: 3, shape: [{dx:0, dy:0}], fixed: false },
      { id: "green1", color: "green1", x: 3, y: 0, shape: [{dx:0, dy:0}], fixed: false },
      { id: "green2", color: "green2", x: 4, y: 0, shape: [{dx:0, dy:0}, {dx:1, dy:0}], fixed: false },
      { id: "yellow", color: "yellow", x: 1, y: 1, shape: [[1,1,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[1,1,0,1,1]].flatMap((row,y)=>row.map((v,x)=>v?{dx:x,dy:y}:null).filter(v=>v)), fixed: false },
      { id: "f1", color: "fixed", x: 0, y: 2, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f2", color: "fixed", x: 5, y: 1, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f3", color: "fixed", x: 3, y: 4, shape: [{dx:0, dy:0}], fixed: true }
    ];

    const startPos = {
      red: { x: 3, y: 3 },
      blue: { x: 5, y: 3 }
    };

    function renderBlocks() {
      puzzle.innerHTML = "";
      
      // ëª©í‘œ ê°€ì´ë“œë¼ì¸ (í¬ê¸° ì¡°ì •ë¨)
      const g1 = document.createElement("div");
      g1.className = "target-guide"; 
      g1.style.left = `${startPos.blue.x * cellSize + 2}px`; 
      g1.style.top = `${startPos.blue.y * cellSize + 2}px`;
      g1.style.borderColor = "#ff4f4f"; puzzle.appendChild(g1);
      
      const g2 = document.createElement("div");
      g2.className = "target-guide"; 
      g2.style.left = `${startPos.red.x * cellSize + 2}px`; 
      g2.style.top = `${startPos.red.y * cellSize + 2}px`;
      g2.style.borderColor = "#339af0"; puzzle.appendChild(g2);

      blocks.forEach(block => {
        const blockDiv = document.createElement("div");
        blockDiv.className = `block ${block.color}`;
        blockDiv.style.left = `${block.x * cellSize}px`;
        blockDiv.style.top = `${block.y * cellSize}px`;

        block.shape.forEach(pos => {
          const cell = document.createElement("div");
          cell.className = "cell";
          // ì…€ ê°„ê²©ì„ ì—†ì• ê¸° ìœ„í•´ 2px ì˜¤í”„ì…‹ ì œê±° ë° ì •ì‚¬ì´ì¦ˆ ë°°ì¹˜
          cell.style.left = `${pos.dx * cellSize}px`;
          cell.style.top = `${pos.dy * cellSize}px`;
          blockDiv.appendChild(cell);
        });

        if (!block.fixed) addDragEvents(blockDiv, block);
        puzzle.appendChild(blockDiv);
      });
      checkWin();
    }

    function getPushChain(block, dx, dy, chain) {
      if (block.fixed) return false;
      if (chain.has(block)) return true;
      chain.add(block);

      for (let p of block.shape) {
        const nx = block.x + p.dx + dx;
        const ny = block.y + p.dy + dy;
        if (nx < 0 || nx >= gridCols || ny < 0 || ny >= gridRows) return false;
        
        for (let other of blocks) {
          if (chain.has(other)) continue;
          for (let op of other.shape) {
            if (nx === other.x + op.dx && ny === other.y + op.dy) {
              if (!getPushChain(other, dx, dy, chain)) return false;
            }
          }
        }
      }
      return true;
    }

    function addDragEvents(el, block) {
      let startX, startY;

      const onStart = (e) => {
        e.preventDefault();
        const clientX = e.clientX || e.touches[0].clientX;
        const clientY = e.clientY || e.touches[0].clientY;
        startX = clientX; startY = clientY;
      };

      const onMove = (e) => {
        if (startX === undefined) return;
        const clientX = e.clientX || (e.touches ? e.touches[0].clientX : 0);
        const clientY = e.clientY || (e.touches ? e.touches[0].clientY : 0);
        
        const distX = (clientX - startX) / cellSize;
        const distY = (clientY - startY) / cellSize;
        
        // ì´ë™ ë¯¼ê°ë„ ì¡°ì •
        if (Math.abs(distX) > 0.4 || Math.abs(distY) > 0.4) {
          let dx = 0, dy = 0;
          if (Math.abs(distX) > Math.abs(distY)) dx = distX > 0 ? 1 : -1;
          else dy = distY > 0 ? 1 : -1;

          const chain = new Set();
          if (getPushChain(block, dx, dy, chain)) {
            chain.forEach(b => { b.x += dx; b.y += dy; });
            startX = clientX; startY = clientY;
            renderBlocks();
          }
        }
      };

      const onEnd = () => {
        if (startX === undefined) return;
        if (JSON.stringify(history[history.length-1]) !== JSON.stringify(blocks)) {
          saveHistory(); moveCount++; updateMoveCount();
        }
        startX = undefined; renderBlocks();
      };

      el.addEventListener("mousedown", onStart);
      window.addEventListener("mousemove", onMove);
      window.addEventListener("mouseup", onEnd);
      el.addEventListener("touchstart", onStart, {passive: false});
      window.addEventListener("touchmove", onMove, {passive: false});
      window.addEventListener("touchend", onEnd);
    }

    function checkWin() {
      const red = blocks.find(b => b.id === "red");
      const blue = blocks.find(b => b.id === "blue");
      if (red.x === startPos.blue.x && red.y === startPos.blue.y &&
          blue.x === startPos.red.x && blue.y === startPos.red.y) {
        successEl.style.display = "block";
      } else { successEl.style.display = "none"; }
    }

    function saveHistory() {
      history.push(JSON.parse(JSON.stringify(blocks)));
      if (history.length > 50) history.shift();
    }

    function undoMove() {
      if (history.length <= 1) return;
      history.pop();
      blocks = JSON.parse(JSON.stringify(history[history.length - 1]));
      moveCount++; updateMoveCount(); renderBlocks();
    }

    function updateMoveCount() { moveCountEl.textContent = moveCount; }
    function resetPuzzle() {
      blocks = JSON.parse(JSON.stringify(initialBlocks));
      history = []; saveHistory(); moveCount = 0; updateMoveCount(); renderBlocks();
    }

    resetPuzzle();
  </script>
</body>
</html>