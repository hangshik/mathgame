<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>ê°•ì•„ì§€ í¼ì¦ - ëª¨ë°”ì¼ ìµœì í™”</title>
  <style>
    body {
      font-family: 'Noto Sans KR', sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #f8f9fa;
      margin: 0;
      padding: 20px;
      color: #333;
      /* ëª¨ë°”ì¼ ì „ì²´ ìŠ¤í¬ë¡¤ ë° ë°”ìš´ìŠ¤ ë°©ì§€ */
      overscroll-behavior: none;
      touch-action: none; 
    }

    .move-counter {
      margin: 12px 0;
      font-weight: 600;
      font-size: 20px;
      color: #495057;
    }

    .puzzle-container {
      display: grid;
      grid-template-columns: repeat(6, 58px);
      grid-template-rows: repeat(5, 58px); 
      position: relative;
      border: 10px solid #343a40;
      border-radius: 10px;
      background-color: #e9ecef;
      width: 348px; 
      height: 290px; 
      box-shadow: 0 8px 20px rgba(0,0,0,0.15);
      /* ëª¨ë°”ì¼ ë“œë˜ê·¸ ìµœì í™” */
      touch-action: none; 
      user-select: none;
      -webkit-user-select: none;
    }
    
    .puzzle-container::before {
      content: "";
      position: absolute;
      top: 0; left: 0; width: 100%; height: 100%;
      pointer-events: none;
      background-image: 
        linear-gradient(to right, #dee2e6 1px, transparent 1px),
        linear-gradient(to bottom, #dee2e6 1px, transparent 1px);
      background-size: 58px 58px;
    }

    .target-guide {
      position: absolute;
      width: 54px; 
      height: 54px;
      border: 3px dashed;
      border-radius: 8px;
      opacity: 0.4;
      z-index: 0;
      box-sizing: border-box;
    }

    .block {
      position: absolute;
      z-index: 1;
      transition: transform 0.1s ease-out, left 0.1s, top 0.1s;
      cursor: grab;
      filter: drop-shadow(2px 3px 4px rgba(0,0,0,0.2));
      -webkit-tap-highlight-color: transparent;
      /* í•µì‹¬: ë¸”ë¡ ìì²´ì—ì„œ ë¸Œë¼ìš°ì € í„°ì¹˜ ì•¡ì…˜ ë§‰ê¸° */
      touch-action: none; 
    }
    .block:active { cursor: grabbing; z-index: 100; }

    .cell {
      position: absolute;
      width: 58px;
      height: 58px;
      box-sizing: border-box;
      border: 0.5px solid rgba(0,0,0,0.05); 
    }

    .red .cell { background-color: #ff4f4f; border: 2px solid #c92a2a; border-radius: 6px; }
    .blue .cell { background-color: #339af0; border: 2px solid #1864ab; border-radius: 6px; }
    .green1 .cell { background-color: #51cf66; border: 2px solid #2b8a3e; border-radius: 6px; }
    .green2 .cell { background-color: #2b8a3e; border: 2px solid #1b4332; border-radius: 6px; }
    .yellow .cell { background-color: #fcc419; border: 1.5px solid #e67700; border-radius: 4px; }
    .fixed .cell { background-color: #343a40; border: 2px solid #000; border-radius: 4px; }

    #success {
      margin-top: 20px;
      font-size: 24px;
      color: #40c057;
      font-weight: 800;
      display: none;
      text-align: center;
    }

    .controls { margin-top: 24px; display: flex; gap: 12px; }
    .btn {
      font-size: 16px; padding: 12px 24px; border: none; border-radius: 8px;
      cursor: pointer; background-color: #339af0; color: white;
      font-weight: 600; transition: 0.2s;
      box-shadow: 0 4px 0 #1c7ed6;
    }
    .btn:active { transform: translateY(2px); box-shadow: none; }
    .btn-secondary { background-color: #adb5bd; box-shadow: 0 4px 0 #868e96; }
  </style>
</head>
<body>
  <h1>ê°•ì•„ì§€ í¼ì¦</h1>
  <!--<h2 style="margin-bottom: 10px; color:#1c7ed6">ë¯¸ì…˜: ë¹¨ê°• â†” íŒŒë‘ ìœ„ì¹˜êµí™˜</h2>-->
  <div class="move-counter">ì´ë™: <span id="moveCount">0</span></div>
  
  <div class="puzzle-container" id="puzzle"></div>
  <div id="success">ğŸ‰ ë¯¸ì…˜ ì„±ê³µ!</div>

  <div class="controls">
    <button class="btn btn-secondary" onclick="undoMove()">ë˜ëŒë¦¬ê¸°</button>
    <button class="btn" onclick="resetPuzzle()">ë‹¤ì‹œ ì‹œì‘</button>
  </div>

  <script>
    const puzzle = document.getElementById("puzzle");
    const moveCountEl = document.getElementById("moveCount");
    const successEl = document.getElementById("success");
    const cellSize = 58; 
    const gridCols = 6;
    const gridRows = 5;

    let blocks = [];
    let moveCount = 0;
    let history = [];

    const initialBlocks = [
      { id: "red", color: "red", x: 3, y: 3, shape: [{dx:0, dy:0}], fixed: false },
      { id: "blue", color: "blue", x: 5, y: 3, shape: [{dx:0, dy:0}], fixed: false },
      { id: "green1", color: "green1", x: 3, y: 0, shape: [{dx:0, dy:0}], fixed: false },
      { id: "green2", color: "green2", x: 4, y: 0, shape: [{dx:0, dy:0}, {dx:1, dy:0}], fixed: false },
      { id: "yellow", color: "yellow", x: 1, y: 1, shape: [[1,1,0,0,0],[0,1,1,1,0],[0,1,0,1,0],[1,1,0,1,1]].flatMap((row,y)=>row.map((v,x)=>v?{dx:x,dy:y}:null).filter(v=>v)), fixed: false },
      { id: "f1", color: "fixed", x: 0, y: 2, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f2", color: "fixed", x: 5, y: 1, shape: [{dx:0, dy:0}], fixed: true },
      { id: "f3", color: "fixed", x: 3, y: 4, shape: [{dx:0, dy:0}], fixed: true }
    ];

    const startPos = { red: { x: 3, y: 3 }, blue: { x: 5, y: 3 } };

    function renderBlocks() {
      puzzle.innerHTML = "";
      
      const g1 = document.createElement("div");
      g1.className = "target-guide"; 
      g1.style.left = `${startPos.blue.x * cellSize + 2}px`; 
      g1.style.top = `${startPos.blue.y * cellSize + 2}px`;
      g1.style.borderColor = "#ff4f4f"; puzzle.appendChild(g1);
      
      const g2 = document.createElement("div");
      g2.className = "target-guide"; 
      g2.style.left = `${startPos.red.x * cellSize + 2}px`; 
      g2.style.top = `${startPos.red.y * cellSize + 2}px`;
      g2.style.borderColor = "#339af0"; puzzle.appendChild(g2);

      blocks.forEach(block => {
        const blockDiv = document.createElement("div");
        blockDiv.className = `block ${block.color}`;
        blockDiv.style.left = `${block.x * cellSize}px`;
        blockDiv.style.top = `${block.y * cellSize}px`;

        block.shape.forEach(pos => {
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.style.left = `${pos.dx * cellSize}px`;
          cell.style.top = `${pos.dy * cellSize}px`;
          blockDiv.appendChild(cell);
        });

        if (!block.fixed) addDragEvents(blockDiv, block);
        puzzle.appendChild(blockDiv);
      });
      checkWin();
    }

    function getPushChain(block, dx, dy, chain) {
      if (block.fixed) return false;
      if (chain.has(block)) return true;
      chain.add(block);

      for (let p of block.shape) {
        const nx = block.x + p.dx + dx;
        const ny = block.y + p.dy + dy;
        if (nx < 0 || nx >= gridCols || ny < 0 || ny >= gridRows) return false;
        
        for (let other of blocks) {
          if (chain.has(other)) continue;
          for (let op of other.shape) {
            if (nx === other.x + op.dx && ny === other.y + op.dy) {
              if (!getPushChain(other, dx, dy, chain)) return false;
            }
          }
        }
      }
      return true;
    }

    function addDragEvents(el, block) {
      let startX, startY;
      let isDragging = false;

      // PointerEvents: ë§ˆìš°ìŠ¤ì™€ í„°ì¹˜ë¥¼ ëª¨ë‘ í¬í•¨í•˜ëŠ” í˜„ëŒ€ì ì¸ ë°©ì‹
      const onStart = (e) => {
        // ëª¨ë°”ì¼ì—ì„œ í„°ì¹˜ ì‹œ ì—‰ëš±í•œ ìš”ì†Œê°€ ì¡íˆì§€ ì•Šë„ë¡ ìº¡ì²˜
        el.setPointerCapture(e.pointerId);
        startX = e.clientX;
        startY = e.clientY;
        isDragging = true;
      };

      const onMove = (e) => {
        if (!isDragging) return;

        const distX = (e.clientX - startX) / cellSize;
        const distY = (e.clientY - startY) / cellSize;
        
        // ì´ë™ ê°ë„: ëª¨ë°”ì¼ì—ì„œëŠ” 0.3 ì •ë„ê°€ ì ë‹¹í•¨
        if (Math.abs(distX) > 0.3 || Math.abs(distY) > 0.3) {
          let dx = 0, dy = 0;
          if (Math.abs(distX) > Math.abs(distY)) dx = distX > 0 ? 1 : -1;
          else dy = distY > 0 ? 1 : -1;

          const chain = new Set();
          if (getPushChain(block, dx, dy, chain)) {
            chain.forEach(b => { b.x += dx; b.y += dy; });
            startX = e.clientX;
            startY = e.clientY;
            renderBlocks();
          }
        }
      };

      const onEnd = (e) => {
        if (!isDragging) return;
        isDragging = false;
        el.releasePointerCapture(e.pointerId);

        if (JSON.stringify(history[history.length-1]) !== JSON.stringify(blocks)) {
          saveHistory(); 
          moveCount++; 
          updateMoveCount();
        }
        renderBlocks();
      };

      // í¬ì¸í„° ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ë“±ë¡
      el.addEventListener("pointerdown", onStart);
      el.addEventListener("pointermove", onMove);
      el.addEventListener("pointerup", onEnd);
      el.addEventListener("pointercancel", onEnd); // ì „í™”ê°€ ì˜¤ëŠ” ë“± ì´ë²¤íŠ¸ ì¤‘ë‹¨ ì‹œ ëŒ€ì‘
    }

    function checkWin() {
      const red = blocks.find(b => b.id === "red");
      const blue = blocks.find(b => b.id === "blue");
      if (red && blue && red.x === startPos.blue.x && red.y === startPos.blue.y &&
          blue.x === startPos.red.x && blue.y === startPos.red.y) {
        successEl.style.display = "block";
      } else { successEl.style.display = "none"; }
    }

    function saveHistory() {
      history.push(JSON.parse(JSON.stringify(blocks)));
      if (history.length > 50) history.shift();
    }

    function undoMove() {
      if (history.length <= 1) return;
      history.pop();
      blocks = JSON.parse(JSON.stringify(history[history.length - 1]));
      moveCount++; updateMoveCount(); renderBlocks();
    }

    function updateMoveCount() { moveCountEl.textContent = moveCount; }
    function resetPuzzle() {
      blocks = JSON.parse(JSON.stringify(initialBlocks));
      history = []; saveHistory(); moveCount = 0; updateMoveCount(); renderBlocks();
    }

    resetPuzzle();
  </script>
</body>

</html>

