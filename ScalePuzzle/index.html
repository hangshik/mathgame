<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>ì €ìš¸ í¼ì¦</title>
  <style>
    :root {
      --bg: #f6f8fa; --muted: #6b7280; --accent: #3b82f6;
      --ok: #16a34a; --danger: #ef4444; --gray: #9ca3af;
      --beam-color: #374151; --pivot-color: #111827;
    }
    html, body {
      height: 100%; margin: 0;
      font-family: Inter, Segoe UI, system-ui, 'Noto Sans KR', sans-serif;
      background: var(--bg); color: #0f172a;
    }
    body, .wrap {
      display: flex; flex-direction: column; align-items: center;
      min-height: 100vh; width: 100vw; box-sizing: border-box;
    }
    .wrap {
      max-width: 980px; margin: 20px auto; padding: 18px; width: 100%;
      display: flex; flex-direction: column; align-items: center;
    }
    h1 { margin: 0 0 8px 0; font-size: 20px; text-align: center; }
    .controls {
      display: flex; flex-wrap: wrap; gap: 8px;
      align-items: center; margin: 12px 0; justify-content: center;
    }
    select, button {
      padding: 8px 12px; border-radius: 8px;
      border: 1px solid rgba(2, 6, 23, 0.06);
      background: var(--gray); color: white;
      font-weight: 600; cursor: pointer; transition: background-color 0.2s;
    }
    select:hover, button:hover { background-color: #7c8593; }
    #checkBtn { background: var(--accent); }
    #checkBtn:hover { background: #60a5fa; }
    .btn-ready { background: var(--ok); }
    .btn-ready:hover { background: #4ade80; }

    #blocks {
      display: flex; gap: 10px; justify-content: center;
      flex-wrap: wrap; margin: 12px 0; min-height: 56px;
    }
    .block-wrapper {
      width: 56px; height: 56px; display: flex;
      align-items: center; justify-content: center;
      /* ë¸”ë¡ì´ í•­ìƒ ìœ„ì— ë³´ì´ë„ë¡ z-index ì¶”ê°€ */
      position: relative;
      z-index: 10;
    }
    .block {
      width: 52px; height: 52px; border-radius: 8px; display: flex;
      align-items: center; justify-content: center; font-weight: 700;
      cursor: grab; background: linear-gradient(180deg, #e0f2fe, #bae6fd);
      box-shadow: 0 4px 10px rgba(2, 6, 23, 0.06);
      user-select: none; transition: box-shadow 0.2s;
      touch-action: none; /* Prevent scrolling while dragging on mobile */
      /* ë¸”ë¡ì´ í•­ìƒ ìœ„ì— ë³´ì´ë„ë¡ z-index ì¶”ê°€ */
      position: relative;
      z-index: 100;
    }
    .block.selected {
      box-shadow: 0 0 0 3px var(--accent);
    }
    
    /* NEW LAYOUT STYLES */
    #answerArea {
      display: flex;
      justify-content: center;
      align-items: center;
      gap: 10px;
      width: 100%;
      max-width: 800px;
      margin: 20px 0 10px 0;
      padding: 10px;
    }
    .slot {
      width: 64px; height: 90px; /* ë†’ì´ ì¡°ì • */
      border-radius: 10px; background: #fff;
      border: 1px solid rgba(2, 6, 23, 0.06); display: flex;
      flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer;
      /* ë¸”ë¡ì´ í•­ìƒ ìœ„ì— ë³´ì´ë„ë¡ z-index ë‚®ê²Œ ì„¤ì • */
      position: relative;
      z-index: 1;
    }
    .slot-inner {
      width: 100%; flex-grow: 1; display: flex;
      align-items: center; justify-content: center;
    }
    .slot-label { font-size: 15px; color: var(--muted); padding-bottom: 5px; }

    .separator {
      width: 30px; /* ì¢Œìš° ìŠ¬ë¡¯ ì‚¬ì´ì˜ ê°„ê²© */
    }

    .fulcrum-line {
      /* widthëŠ” ìë°”ìŠ¤í¬ë¦½íŠ¸ì—ì„œ ë™ì ìœ¼ë¡œ ì¡°ì ˆë¨ */
      height: 8px;
      background: linear-gradient(90deg, var(--pivot-color), var(--beam-color), var(--pivot-color));
      border-radius: 6px;
      margin: 0 auto;
      transition: width 0.2s;
      /* max-width: 820px;  ì œê±° */
      display: block;
    }
    .fulcrum-pivot {
      width: 0; height: 0;
      border-left: 28px solid transparent;
      border-right: 28px solid transparent;
      border-bottom: 36px solid var(--pivot-color);
      margin-top: -2px; /* ë¼ì¸ê³¼ ì‚´ì§ ê²¹ì¹˜ë„ë¡ */
    }
    
    .message {
      min-height: 22px; margin-top: 16px; font-weight: 700; text-align: center; font-size: 20px;
    }
    .message.ok { color: var(--ok); }
    .message.err { color: var(--danger); }
    .meta {
      display: flex; justify-content: center; align-items: center;
      margin-top: 10px; color: var(--muted); font-size: 22px; width: 100%;
      text-align: center;
    }

    @media (max-width: 720px) {
      #answerArea { gap: 6px; }
      .slot { width: 50px; height: 60px; }
      .block-wrapper { width: 48px; height: 48px; }
      .block { width: 44px; height: 44px; font-size: 14px; }
      .separator { width: 15px; }
      .fulcrum-pivot { border-left-width: 20px; border-right-width: 20px; border-bottom-width: 28px; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>âš–ï¸ ì €ìš¸ í¼ì¦</h1>

    <div class="controls">
      <label>ì¢Œ/ìš° ìŠ¬ë¡¯ ìˆ˜: <select id="slotCount"><option selected>3</option><option>4</option><option>5</option></select></label>
      <label>ë¸”ë¡ ìˆ˜: <select id="blockCount"></select></label>
      <button id="newBtn">ìƒˆ í¼ì¦</button>
      <button id="resetBtn">ì´ˆê¸°í™”</button>
      <button id="hintBtn">íŒíŠ¸</button>
      <button id="checkBtn">ì •ë‹µ í™•ì¸</button>
    </div>

    <div id="blocks" aria-label="ë¸”ë¡ ëª©ë¡"></div>
    
    <div id="answerArea"></div>
    <div class="fulcrum-line"></div>
    <div class="fulcrum-pivot"></div>

    <div id="message" class="message"></div>

    <div class="meta">
      <div>ì •ë‹µ ë§ì¶˜ íšŸìˆ˜: <strong id="score">0</strong></div>
    </div>
  </div>

<script>
    let score = 0;
    let currentWeights = [];
    let solution = [];
    let hintIndex = 0;
    let selectedBlock = null;
    let dragBlock = null; // For touch drag
    let isCorrect = false; // ì •ë‹µ ìƒíƒœ í”Œë˜ê·¸

    const U = {
        slotCount: document.getElementById('slotCount'),
        blockCount: document.getElementById('blockCount'),
        blocks: document.getElementById('blocks'),
        answerArea: document.getElementById('answerArea'),
        newBtn: document.getElementById('newBtn'),
        resetBtn: document.getElementById('resetBtn'),
        hintBtn: document.getElementById('hintBtn'),
        checkBtn: document.getElementById('checkBtn'),
        message: document.getElementById('message'),
        score: document.getElementById('score'),
        fulcrumLine: document.querySelector('.fulcrum-line'),
    };

    function updateBlockOptions() {
        const s = parseInt(U.slotCount.value, 10);
        U.blockCount.innerHTML = '';
        for (let i = 3; i <= s * 2; i++) {
            const o = document.createElement('option');
            o.value = i;
            o.textContent = i;
            U.blockCount.appendChild(o);
        }
        U.blockCount.value = Math.min(s * 2, 3);
    }

    // fulcrum-lineì˜ ê¸¸ì´ë¥¼ ìŠ¬ë¡¯ ìˆ˜ì— ë§ê²Œ ì¡°ì ˆ
    function updateFulcrumLineWidth() {
        // ìŠ¬ë¡¯ ê°œìˆ˜(ì¢Œ+ìš°)ì™€ separatorì˜ ê°œìˆ˜ì— ë”°ë¼ ê³„ì‚°
        const slotCount = parseInt(U.slotCount.value, 10);
        // slotì˜ width, gap, separator widthë¥¼ CSSì—ì„œ ê°€ì ¸ì˜´
        // slot: 64px, gap: 10px, separator: 30px (PC ê¸°ì¤€)
        // ëª¨ë°”ì¼ì€ 50, 6, 15
        let slotW = 64, gap = 10, sepW = 30;
        if (window.innerWidth <= 720) {
            slotW = 50; gap = 6; sepW = 15;
        }
        // ì „ì²´ ìŠ¬ë¡¯ ê°œìˆ˜: ì¢Œ+ìš°
        const totalSlots = slotCount * 2;
        // gap ê°œìˆ˜: ìŠ¬ë¡¯ ì‚¬ì´ (ì¢Œì¸¡ n-1, separator ì•ë’¤ 1, ìš°ì¸¡ n-1) = (n-1) + 1 + (n-1) = 2n-1
        // ì‹¤ì œ answerAreaì˜ gapì€ flexë¡œ ìë™ì´ì§€ë§Œ, separatorê°€ ìˆìœ¼ë‹ˆ slotCount*2-1ê°œ gap
        const totalGap = (totalSlots - 1) * gap;
        // ì „ì²´ ê¸¸ì´ = ìŠ¬ë¡¯*ê°œìˆ˜ + gap*ê°œìˆ˜ + separator
        const totalWidth = (slotW * totalSlots) + totalGap + sepW + 30;
        U.fulcrumLine.style.width = totalWidth + "px";
    }

    function createSlots() {
        const s = parseInt(U.slotCount.value, 10);
        U.answerArea.innerHTML = ''; 

        // ì™¼ìª½ ìŠ¬ë¡¯ ìƒì„±
        for (let i = 0; i < s; i++) {
            const dist = s - i;
            const slot = createSingleSlot(dist, 'left', i);
            U.answerArea.appendChild(slot);
        }

        // êµ¬ë¶„ì
        const separator = document.createElement('div');
        separator.className = 'separator';
        U.answerArea.appendChild(separator);

        // ì˜¤ë¥¸ìª½ ìŠ¬ë¡¯ ìƒì„±
        for (let i = 0; i < s; i++) {
            const dist = i + 1;
            const slot = createSingleSlot(dist, 'right', i);
            U.answerArea.appendChild(slot);
        }

        // ìŠ¬ë¡¯ ìƒì„± í›„ fulcrum-line ê¸¸ì´ ì¡°ì •
        updateFulcrumLineWidth();
    }

    function createSingleSlot(dist, side, index) {
        const slot = document.createElement('div');
        slot.className = 'slot';
        slot.dataset.side = side;
        slot.dataset.dist = dist;
        slot.dataset.index = index;

        const inner = document.createElement('div');
        inner.className = 'slot-inner';
        const labelEl = document.createElement('div');
        labelEl.className = 'slot-label';
        labelEl.textContent = dist;
        slot.appendChild(inner);
        slot.appendChild(labelEl);
        attachSlotEvents(slot);
        return slot;
    }

    function handleBlockPlacement(targetSlot, blockToPlace) {
        const sourceParent = blockToPlace.parentElement;
        const existingBlock = targetSlot.querySelector('.block');

        if (existingBlock === blockToPlace) return;

        if (existingBlock) {
            sourceParent.appendChild(existingBlock);
            if (selectedBlock === blockToPlace) {
                deselectAllBlocks();
                selectBlock(existingBlock);
            }
        } else {
            // if (selectedBlock === blockToPlace) deselectAllBlocks();
        }
        targetSlot.querySelector('.slot-inner').appendChild(blockToPlace);
        setMessage('');
    }

    function attachSlotEvents(slot) {
        // Drag & Drop (desktop)
        slot.addEventListener('dragover', e => e.preventDefault());
        slot.addEventListener('drop', e => {
            e.preventDefault();
            const blockId = e.dataTransfer.getData('text');
            const blockEl = document.getElementById(blockId);
            if (!blockEl) return;
            deselectAllBlocks();
            handleBlockPlacement(slot, blockEl);
        });

        // Click: place selected block, or select block in slot
        slot.addEventListener('click', (e) => {
            // If block is in slot and user clicks it, select it
            const block = slot.querySelector('.block');
            if (block && e.target.closest('.block')) {
                // Select the block in the slot
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }
                return;
            }
            // Otherwise, try to place selected block
            if (selectedBlock) {
                handleBlockPlacement(slot, selectedBlock);
            }
        });

        // Touch support for mobile drag & drop
        slot.addEventListener('touchstart', function(e) {
            // If block is in slot and user touches it, select it
            const block = slot.querySelector('.block');
            if (block && e.target.closest('.block')) {
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }
                // For drag: allow dragging block from slot
                dragBlock = block;
                // Prevent scroll
                e.preventDefault();
                return;
            }
            // If a block is selected, place it here
            if (selectedBlock) {
                handleBlockPlacement(slot, selectedBlock);
                e.preventDefault();
            }
        }, {passive: false});

        // Touch drop target for mobile drag
        slot.addEventListener('touchmove', function(e) {
            // Prevent scroll while dragging over slot
            if (dragBlock) e.preventDefault();
        }, {passive: false});

        slot.addEventListener('touchend', function(e) {
            if (dragBlock) {
                handleBlockPlacement(slot, dragBlock);
                dragBlock = null;
                deselectAllBlocks();
                e.preventDefault();
            }
        }, {passive: false});
    }

    function selectBlock(block) {
        deselectAllBlocks();
        block.classList.add('selected');
        selectedBlock = block;
    }

    function deselectAllBlocks() {
        document.querySelectorAll('.block.selected').forEach(b => b.classList.remove('selected'));
        selectedBlock = null;
    }

    function createBlocks(n) {
        U.blocks.innerHTML = '';
        currentWeights = [];
        for (let i = 0; i < n; i++) {
            const wrapper = document.createElement('div');
            wrapper.className = 'block-wrapper';
            const block = document.createElement('div');
            block.className = 'block';
            block.id = 'block' + i;
            const weight = Math.floor(Math.random() * 9) + 1;
            block.textContent = weight;
            block.dataset.weight = weight;
            block.draggable = true;

            // Desktop drag
            block.addEventListener('dragstart', e => {
                deselectAllBlocks();
                e.dataTransfer.setData('text', block.id);
            });

            // Click: select/deselect
            block.addEventListener('click', (e) => {
                e.stopPropagation();
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }
            });

            // Touch support for mobile drag
            let touchMoved = false;
            let touchStartX = 0, touchStartY = 0;
            block.addEventListener('touchstart', function(e) {
                // ğŸ‘‰ ë‹¨ìˆœ í„°ì¹˜ë§Œìœ¼ë¡œ ì„ íƒ/í•´ì œ
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }

                // í•„ìš”í•  ë•Œë§Œ ë“œë˜ê·¸ ì‹œì‘
                dragBlock = block;

                // í„°ì¹˜ ìŠ¤í¬ë¡¤ ë°©ì§€
                e.preventDefault();
           }, {passive: false});


            block.addEventListener('touchmove', function(e) {
                if (!dragBlock) return;
                touchMoved = true;
                // Optionally, show visual feedback
                e.preventDefault();
            }, {passive: false});

            block.addEventListener('touchend', function(e) {
                if (!dragBlock) return;
                // Find the element under the touch point
                let touch = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]);
                if (!touch) {
                    dragBlock = null;
                    return;
                }
                const x = touch.clientX, y = touch.clientY;
                dragBlock.classList.remove('selected');
                selectedBlock = null;
                // Find slot under touch
                const el = document.elementFromPoint(x, y);
                const slot = el && el.closest && el.closest('.slot');
                if (slot) {
                    handleBlockPlacement(slot, block);
                } else {
                    // Find block-wrapper under touch
                    const wrapper = el && el.closest && el.closest('.block-wrapper');
                    if (wrapper) {
                        wrapper.appendChild(block);
                    } else {
                        // If not on a wrapper, find any empty wrapper
                        const emptyWrapper = findEmptyWrapper();
                        if (emptyWrapper) emptyWrapper.appendChild(block);
                    }
                }
                dragBlock = null;
                setMessage('');
                e.preventDefault();
            }, {passive: false});

            wrapper.appendChild(block);
            U.blocks.appendChild(wrapper);
            currentWeights.push(weight);
        }
    }
    
    function findEmptyWrapper() {
        return Array.from(U.blocks.querySelectorAll('.block-wrapper')).find(w => !w.querySelector('.block'));
    }

    // Desktop drag & drop for block area
    U.blocks.addEventListener('dragover', e => e.preventDefault());
    U.blocks.addEventListener('drop', e => {
        e.preventDefault();
        const blockId = e.dataTransfer.getData('text');
        const blockEl = document.getElementById(blockId);
        if (!blockEl) return;
        const emptyWrapper = findEmptyWrapper();
        if (emptyWrapper) {
            emptyWrapper.appendChild(blockEl);
        }
        setMessage('');
    });

    // Touch drop for block area (mobile)
    U.blocks.addEventListener('touchmove', function(e) {
        if (dragBlock) e.preventDefault();
    }, {passive: false});
    U.blocks.addEventListener('touchend', function(e) {
        if (!dragBlock) return;
        let touch = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]);
        if (!touch) {
            dragBlock = null;
            return;
        }
        const x = touch.clientX, y = touch.clientY;
        dragBlock.classList.remove('selected');
        selectedBlock = null;
        // Find block-wrapper under touch
        const el = document.elementFromPoint(x, y);
        const wrapper = el && el.closest && el.closest('.block-wrapper');
        if (wrapper) {
            wrapper.appendChild(dragBlock);
        } else {
            // If not on a wrapper, find any empty wrapper
            const emptyWrapper = findEmptyWrapper();
            if (emptyWrapper) emptyWrapper.appendChild(dragBlock);
        }
        dragBlock = null;
        setMessage('');
        e.preventDefault();
    }, {passive: false});
    
    document.body.addEventListener('click', (e) => {
        if (!e.target.closest('.block, .slot')) {
            deselectAllBlocks();
        }
    });

    // --- ìŠ¬ë¡¯ì— ìˆëŠ” ë¸”ë¡ë„ ì„ íƒ ë° ì´ë™ ê°€ëŠ¥í•˜ê²Œ ---
    // (1) .blockì— ëŒ€í•´ í•­ìƒ select/deselect ë° drag ê°€ëŠ¥í•˜ê²Œ ì´ë¯¸ êµ¬í˜„ë¨
    // (2) .blockì´ slot ì•ˆì— ìˆë“  block-wrapper ì•ˆì— ìˆë“  ë™ì¼í•˜ê²Œ ë™ì‘

    // (3) block-wrapperì—ë„ drop ì´ë²¤íŠ¸ë¥¼ í•­ìƒ ë“±ë¡ (ë™ì ìœ¼ë¡œ ìƒì„±ë˜ëŠ” ê²½ìš°ë„ í¬í•¨)
    function addBlockWrapperDropEvents(wrapper) {
        wrapper.addEventListener('dragover', e => e.preventDefault());
        wrapper.addEventListener('drop', e => {
            e.preventDefault();
            const blockId = e.dataTransfer.getData('text');
            const blockEl = document.getElementById(blockId);
            if (!blockEl) return;
            wrapper.appendChild(blockEl);
            setMessage('');
        });
    }

    // ê¸°ì¡´ block-wrapperì— drop ì´ë²¤íŠ¸ ë“±ë¡
    function addDropEventsToAllWrappers() {
        U.blocks.querySelectorAll('.block-wrapper').forEach(addBlockWrapperDropEvents);
    }

    // ìµœì´ˆì— í•œ ë²ˆë§Œ í˜¸ì¶œ
    addDropEventsToAllWrappers();

    // createBlocksì—ì„œ ìƒˆë¡œ ìƒì„±ë˜ëŠ” wrapperì—ë„ drop ì´ë²¤íŠ¸ ë“±ë¡
    const _origCreateBlocks = createBlocks;
    createBlocks = function(n) {
        U.blocks.innerHTML = '';
        currentWeights = [];
        for (let i = 0; i < n; i++) {
            const wrapper = document.createElement('div');
            wrapper.className = 'block-wrapper';
            addBlockWrapperDropEvents(wrapper);
            const block = document.createElement('div');
            block.className = 'block';
            block.id = 'block' + i;
            const weight = Math.floor(Math.random() * 9) + 1;
            block.textContent = weight;
            block.dataset.weight = weight;
            block.draggable = true;

            // Desktop drag
            block.addEventListener('dragstart', e => {
                deselectAllBlocks();
                e.dataTransfer.setData('text', block.id);
            });

            // Click: select/deselect
            block.addEventListener('click', (e) => {
                e.stopPropagation();
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }
            });

            // Touch support for mobile drag
            let touchMoved = false;
            let touchStartX = 0, touchStartY = 0;
            block.addEventListener('touchstart', function(e) {
                if (block.classList.contains('selected')) {
                    deselectAllBlocks();
                } else {
                    selectBlock(block);
                }
                // For drag
                dragBlock = block;
                touchMoved = false;
                if (e.touches && e.touches.length > 0) {
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                }
                // Prevent scroll
                e.preventDefault();
            }, {passive: false});

            block.addEventListener('touchmove', function(e) {
                if (!dragBlock) return;
                touchMoved = true;
                // Optionally, show visual feedback
                e.preventDefault();
            }, {passive: false});

            block.addEventListener('touchend', function(e) {
                if (!dragBlock) return;
                // Find the element under the touch point
                let touch = (e.changedTouches && e.changedTouches[0]) || (e.touches && e.touches[0]);
                if (!touch) {
                    dragBlock = null;
                    return;
                }
                const x = touch.clientX, y = touch.clientY;
                dragBlock.classList.remove('selected');
                selectedBlock = null;
                // Find slot under touch
                const el = document.elementFromPoint(x, y);
                const slot = el && el.closest && el.closest('.slot');
                if (slot) {
                    handleBlockPlacement(slot, block);
                } else {
                    // Find block-wrapper under touch
                    const wrapper = el && el.closest && el.closest('.block-wrapper');
                    if (wrapper) {
                        wrapper.appendChild(block);
                    } else {
                        // If not on a wrapper, find any empty wrapper
                        const emptyWrapper = findEmptyWrapper();
                        if (emptyWrapper) emptyWrapper.appendChild(block);
                    }
                }
                dragBlock = null;
                setMessage('');
                e.preventDefault();
            }, {passive: false});

            wrapper.appendChild(block);
            U.blocks.appendChild(wrapper);
            currentWeights.push(weight);
        }
    }

    function computeTorque() {
        let leftTorque = 0, rightTorque = 0;
        Array.from(U.answerArea.querySelectorAll('.slot')).forEach(slot => {
            const block = slot.querySelector('.block');
            if (block) {
                const dist = Number(slot.dataset.dist);
                const side = slot.dataset.side;
                if (side === 'left') {
                    leftTorque += Number(block.dataset.weight) * dist;
                } else if (side === 'right') {
                    rightTorque += Number(block.dataset.weight) * dist;
                }
            }
        });
        return { L: leftTorque, R: rightTorque };
    }

    function setMessage(text, type = '') {
        U.message.textContent = text;
        U.message.className = type ? `message ${type === 'ok' ? 'ok' : 'err'}` : 'message';
    }

    function allBlocksUsed() {
        return U.blocks.querySelectorAll('.block').length === 0;
    }
    
    function solvePuzzle(values, slotCount) {
        const positions = [];
        for (let d = 1; d <= slotCount; d++) positions.push({ side: 'left', dist: d });
        for (let d = 1; d <= slotCount; d++) positions.push({ side: 'right', dist: d });
        
        const used = Array(positions.length).fill(false);
        let solutionResult = [];
        let found = false;
        
        function dfs(blockIdx, leftTorque, rightTorque, currentSolution) {
            if (found) return;
            if (blockIdx === values.length) {
                if (leftTorque === rightTorque && leftTorque > 0) {
                    solutionResult = [...currentSolution];
                    found = true;
                }
                return;
            }
            
            for (let pIdx = 0; pIdx < positions.length; pIdx++) {
                if (used[pIdx]) continue;
                
                used[pIdx] = true;
                const pos = positions[pIdx];
                const weight = values[blockIdx];
                
                if (pos.side === 'left') {
                    currentSolution.push({ blockIndex: blockIdx, side: 'left', slotIndex: slotCount - pos.dist });
                    dfs(blockIdx + 1, leftTorque + weight * pos.dist, rightTorque, currentSolution);
                } else {
                    currentSolution.push({ blockIndex: blockIdx, side: 'right', slotIndex: pos.dist - 1 });
                    dfs(blockIdx + 1, leftTorque, rightTorque + weight * pos.dist, currentSolution);
                }
                
                if (found) return;
                currentSolution.pop();
                used[pIdx] = false;
            }
        }
        dfs(0, 0, 0, []);
        return solutionResult;
    }

    function generateSolvablePuzzle(slotCount, blockCount) {
        setMessage('ìƒˆ í¼ì¦ ìƒì„± ì¤‘...');
        U.newBtn.disabled = true;
        U.checkBtn.disabled = false;
        isCorrect = false;
        setTimeout(() => {
            let attempts = 0;
            while (attempts < 200) {
                createSlots();
                createBlocks(blockCount);
                const values = Array.from(U.blocks.querySelectorAll('.block')).map(b => Number(b.dataset.weight));
                const sol = solvePuzzle(values, slotCount);
                if (sol.length > 0) {
                    solution = sol;
                    hintIndex = 0;
                    setMessage('');
                    U.newBtn.classList.remove('btn-ready');
                    U.newBtn.disabled = false;
                    U.checkBtn.disabled = false;
                    isCorrect = false;
                    return;
                }
                attempts++;
            }
            setMessage('í¼ì¦ ìƒì„± ì‹¤íŒ¨. ì„¤ì •ì„ ë³€ê²½í•´ì£¼ì„¸ìš”.', 'err');
            U.newBtn.disabled = false;
        }, 10);
    }
    
    function newPuzzle() {
        generateSolvablePuzzle(Number(U.slotCount.value), Number(U.blockCount.value));
    }

    function showHint() {
        if (hintIndex >= solution.length) {
            setMessage('ë” ì´ìƒ íŒíŠ¸ê°€ ì—†ìŠµë‹ˆë‹¤.', 'err');
            return;
        }
        const step = solution[hintIndex];
        const targetSlot = U.answerArea.querySelector(`.slot[data-side='${step.side}'][data-index='${step.slotIndex}']`);
        const blockEl = document.getElementById('block' + step.blockIndex);

        if (!blockEl || !targetSlot) {
            hintIndex++;
            if (hintIndex < solution.length) showHint();
            return;
        }

        handleBlockPlacement(targetSlot, blockEl);
        hintIndex++;
        setMessage('íŒíŠ¸: ë¸”ë¡ í•˜ë‚˜ë¥¼ ì •ë‹µ ìœ„ì¹˜ì— ë°°ì¹˜í–ˆìŠµë‹ˆë‹¤.');

        if (allBlocksUsed() && hintIndex >= solution.length) {
            checkAnswer();
        }
    }

    function checkAnswer() {
        if (isCorrect) return; // ì´ë¯¸ ì •ë‹µì´ë©´ ë™ì‘í•˜ì§€ ì•ŠìŒ
        if (!allBlocksUsed()) {
            setMessage('ëª¨ë“  ë¸”ë¡ì„ ì‚¬ìš©í•˜ì„¸ìš”.', 'err');
            return;
        }
        const t = computeTorque();
        if (t.L > 0 && t.R > 0 && t.L === t.R) {
            score++;
            U.score.textContent = score;
            setMessage('ì •ë‹µ! ê· í˜•ì´ ë§ì•˜ìŠµë‹ˆë‹¤ ğŸ‰', 'ok');
            U.newBtn.classList.add('btn-ready');
            U.checkBtn.disabled = true; // ì •ë‹µì´ë©´ ë²„íŠ¼ ë¹„í™œì„±í™”
            isCorrect = true;
        } else {
            setMessage(`í‹€ë ¸ìŠµë‹ˆë‹¤. ì¢Œ: ${t.L} / ìš°: ${t.R} ì…ë‹ˆë‹¤.`, 'err');
        }
    }

    function resetBoard() {
        const wrappers = Array.from(U.blocks.querySelectorAll('.block-wrapper'));
        const blocks = Array.from(document.querySelectorAll('.block'));
        
        wrappers.forEach(w => { if (w.firstChild) w.removeChild(w.firstChild); });

        blocks.forEach(block => {
            const originalIndex = parseInt(block.id.replace('block', ''), 10);
            if (wrappers[originalIndex]) {
                wrappers[originalIndex].appendChild(block);
            }
        });
        
        document.querySelectorAll('.slot-inner').forEach(inner => {
            if (inner.firstChild) inner.removeChild(inner.firstChild);
        });

        const allBlocksOnBoard = document.querySelectorAll('.block');
        allBlocksOnBoard.forEach(b => {
             const originalIndex = parseInt(b.id.replace('block', ''), 10);
             if (wrappers[originalIndex] && !wrappers[originalIndex].firstChild) {
                wrappers[originalIndex].appendChild(b);
            }
        });

        hintIndex = 0;
        setMessage('');
        deselectAllBlocks();
        U.newBtn.classList.remove('btn-ready');
        U.checkBtn.disabled = false; // ë¦¬ì…‹ ì‹œ ë²„íŠ¼ í™œì„±í™”
        isCorrect = false;
    }

    // ìŠ¬ë¡¯ ìˆ˜ ë³€ê²½ ì‹œ fulcrum-line ê¸¸ì´ë„ ì¡°ì •
    U.slotCount.addEventListener('change', () => {
        updateBlockOptions();

    });

    // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì‹œ fulcrum-line ê¸¸ì´ë„ ì¡°ì •
    window.addEventListener('resize', updateFulcrumLineWidth);

    U.newBtn.addEventListener('click', newPuzzle);
    U.resetBtn.addEventListener('click', resetBoard);
    U.hintBtn.addEventListener('click', showHint);
    U.checkBtn.addEventListener('click', checkAnswer);

    updateBlockOptions();
    createSlots();
    updateFulcrumLineWidth();
    newPuzzle();
</script>
</body>
</html>
