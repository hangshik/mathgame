<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>스트링아트</title>
<style>
  body {
    font-family: 'Arial', sans-serif;
    padding: 20px;
    background: #f0f0f0;
    text-align: center;
  }
  label {
    margin: 0 10px;
    font-weight: bold;
  }
  input, select, button {
    margin: 0 5px 15px;
    padding: 5px 10px;
    font-size: 1rem;
  }
  canvas {
    background: white;
    border: 1px solid #ccc;
    margin-top: 10px;
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
  #controls {
    margin-bottom: 10px;
  }
</style>
</head>
<body>

<h1>스트링아트 그리기</h1>

<div>
  <label for="radius">크기:</label>
  <input type="number" id="radius" min="50" max="350" value="150" />
  
  <label for="shape">도형:</label>
  <select id="shape">
    <option value="circle" selected>원</option>
    <option value="3">삼각형</option>
    <option value="4">사각형</option>
    <option value="5">오각형</option>
    <option value="6">육각형</option>
  </select>
  
  <label for="points">점의 수:</label>
  <input type="number" id="points" min="2" max="200" value="30" />

  <label for="skip">건너는 수:</label>
  <input type="number" id="skip" min="1" max="100" value="6" />

  <label for="skipAdd">더한 수:</label>
  <input type="number" id="skipAdd" min="0" max="50" value="0" />
  
  <label for="colorMode">색상 모드:</label>
  <select id="colorMode">
    <option value="single" selected>단색</option>
    <option value="multi">다채색</option>
  </select>

  <label for="color">선 색상:</label>
  <input type="color" id="color" value="#0088cc" />
</div>

<div id="controls">
  <button id="drawOne">하나씩 그리기</button>
  <button id="drawAll">전체 그리기</button>
  <button id="reset">초기화</button>
</div>

<canvas id="canvas"></canvas>
<br><br>
<div>
  키보드: 하나씩 그리기(Space), 전체 그리기(Enter), 초기화(Esc)
</div>

<script>
  const radiusInput = document.getElementById('radius');
  const pointsInput = document.getElementById('points');
  const shapeSelect = document.getElementById('shape');
  const skipInput = document.getElementById('skip');
  const skipAddInput = document.getElementById('skipAdd');
  const colorMode = document.getElementById('colorMode');
  const colorInput = document.getElementById('color');
  const canvas = document.getElementById('canvas');
  const ctx = canvas.getContext('2d');

  const drawOneBtn = document.getElementById('drawOne');
  const drawAllBtn = document.getElementById('drawAll');
  const resetBtn = document.getElementById('reset');

  let points = [];
  let currentLineIndex = 0;

  function setupCanvas() {
    const radius = parseInt(radiusInput.value);
    const size = Math.min(900, radius * 2 + 120);
    canvas.width = size;
    canvas.height = size;
  }

  function calculatePoints(shape, radius, pointsPerSide, centerX, centerY) {
  const pts = [];
  if (shape === "circle") {
    for (let i = 0; i < pointsPerSide; i++) {
      const angle = (2 * Math.PI * i) / pointsPerSide - Math.PI / 2;
      const x = centerX + radius * Math.cos(angle);
      const y = centerY + radius * Math.sin(angle);
      pts.push({ x, y });
    }
  } else {
    const sides = parseInt(shape);
    const angleStep = (2 * Math.PI) / sides;
    const rotationOffset = (sides === 4 ? Math.PI / 4 : 0);
    const verts = [];
    for (let i = 0; i < sides; i++) {
      const a = angleStep * i - Math.PI / 2 + rotationOffset;
      verts.push({ x: centerX + radius * Math.cos(a), y: centerY + radius * Math.sin(a) });
    }
    for (let e = 0; e < sides; e++) {
      const v0 = verts[e];
      const v1 = verts[(e + 1) % sides];
      for (let j = 0; j < pointsPerSide; j++) {
        const t = j / pointsPerSide;
        const x = v0.x + (v1.x - v0.x) * t;
        const y = v0.y + (v1.y - v0.y) * t;
        pts.push({ x, y });
      }
    }
  }
  return pts;
}

function init() {
  currentLineIndex = 0;
  const radius = parseInt(radiusInput.value);
  const shape = shapeSelect.value;

  // 도형이 바뀔 때 기본값 설정
  if (document.activeElement === shapeSelect) {
    if (shape === "circle") {
      pointsInput.value = 30;
    } else {
      pointsInput.value = 5;
    }
    skipInput.value = 6;
    skipAddInput.value = 0;
  }

  let perSide = parseInt(pointsInput.value);

  setupCanvas();
  points = calculatePoints(shape, radius, perSide, canvas.width / 2, canvas.height / 2);
  drawBase(shape, radius);
}



  function drawBase(shape, radius) {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    ctx.fillStyle = "white";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    ctx.strokeStyle = "#222";
    ctx.lineWidth = 1;
    ctx.beginPath();
    if (shape === "circle") {
      ctx.arc(cx, cy, radius, 0, 2 * Math.PI);
    } else {
      const sides = parseInt(shape);
      const angleStep = (2 * Math.PI) / sides;
      const rotationOffset = (sides === 4 ? Math.PI / 4 : 0);
      for (let i = 0; i < sides; i++) {
        const a = angleStep * i - Math.PI / 2 + rotationOffset;
        const x = cx + radius * Math.cos(a);
        const y = cy + radius * Math.sin(a);
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
      }
      ctx.closePath();
    }
    ctx.stroke();

    ctx.fillStyle = "#444";
    points.forEach(p => {
      ctx.beginPath();
      ctx.arc(p.x, p.y, 3, 0, 2 * Math.PI);
      ctx.fill();
    });

    ctx.fillStyle = "#222";
    ctx.font = "14px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    const labelOffset = 20;
    points.forEach(p => {
      let nx = p.x;
      let ny = p.y;
      if (shape === "circle") {
        const ang = Math.atan2(p.y - cy, p.x - cx);
        nx = cx + (radius + labelOffset) * Math.cos(ang);
        ny = cy + (radius + labelOffset) * Math.sin(ang);
      } else {
        const dirX = p.x - cx;
        const dirY = p.y - cy;
        const len = Math.sqrt(dirX*dirX + dirY*dirY);
        nx = p.x + (dirX/len)*labelOffset;
        ny = p.y + (dirY/len)*labelOffset;
      }
      ctx.fillText(points.indexOf(p) + 1, nx, ny);
    });
  }

  function clearLines() {
    const radius = parseInt(radiusInput.value);
    const shape = shapeSelect.value;
    drawBase(shape, radius);
  }

  function getLineColor(i) {
    if (colorMode.value === "multi") {
      const hue = (i * 137.508) % 360;
      return `hsl(${hue}, 100%, 45%)`;
    }
    return colorInput.value;
  }
  function drawNextLine() {
    const n = points.length;
    const baseSkip = parseInt(skipInput.value);
    const inc = parseInt(skipAddInput.value);
    if (currentLineIndex >= n) return;

    const start = points[currentLineIndex];
    const skipForThis = baseSkip + inc * currentLineIndex;
    const endIndex = (currentLineIndex + skipForThis) % n;
    const end = points[endIndex];

    ctx.strokeStyle = getLineColor(currentLineIndex);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(start.x, start.y);
    ctx.lineTo(end.x, end.y);
    ctx.stroke();

    currentLineIndex++;
  }

  function drawAllLines() {
    const n = points.length;
    const baseSkip = parseInt(skipInput.value);
    const inc = parseInt(skipAddInput.value);

    ctx.lineWidth = 1.5;
    for (let i = 0; i < n; i++) {
      const start = points[i];
      const skipForThis = baseSkip + inc * i;
      const endIndex = (i + skipForThis) % n;
      const end = points[endIndex];
      ctx.strokeStyle = getLineColor(i);
      ctx.beginPath();
      ctx.moveTo(start.x, start.y);
      ctx.lineTo(end.x, end.y);
      ctx.stroke();
    }
    currentLineIndex = n;
  }




  [radiusInput, pointsInput, shapeSelect, skipInput, skipAddInput, colorMode, colorInput].forEach(el => 
    el.addEventListener('input', init)
  );

  drawOneBtn.addEventListener('click', drawNextLine);
  drawAllBtn.addEventListener('click', () => { clearLines(); drawAllLines(); });
  resetBtn.addEventListener('click', init);

  document.addEventListener('keydown', e => {
    if (e.code === 'Space') { e.preventDefault(); drawNextLine(); }
    else if (e.code === 'Enter') { e.preventDefault(); clearLines(); drawAllLines(); }
    else if (e.code === 'Escape') { e.preventDefault(); init(); }
  });

  init();
</script>

</body>
</html>
