<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>태국 탈출 퍼즐</title>
  <style>
    body {
      font-family: Arial, sans-serif;
      display: flex;
      flex-direction: column;
      align-items: center;
      background-color: #ffffff;
      margin: 0;
      padding: 20px;
    }
    .controls {
      margin-bottom: 10px;
    }
    .move-counter {
      margin-bottom: 10px;
      font-weight: bold;
      font-size: 24px;
    }
    .puzzle-container {
      display: grid;
      grid-template-columns: repeat(4, 60px);
      grid-template-rows: repeat(5, 60px);
      gap: 0;
      position: relative;
      border: 12px solid #f3e075;
    }

    /* 아래 테두리1/2 덮기 */
    .puzzle-container::after {
      content: "";
      position: absolute;
      bottom: -12px; /* border 두께만큼 내려감 */
      left: 25%;     /* 1/4부터 시작 */
      width: 50%;
      height: 12px;  /* border 두께 */
      background-color: white;
      z-index: 1;
    }
    
    .puzzle-container::before {
      content: "";
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-size: 60px 60px;
      background-color: #ddd;
      pointer-events: none;
      z-index: 0;
    }
    .block {
      position: absolute;
      display: flex;
      justify-content: center;
      align-items: center;
      background-color: #e6d8fc;
      border: 1px solid purple;
      z-index: 1;
      box-sizing: border-box;
      transition: left 0.2s, top 0.2s;
      border-radius: 3px; /* 블록 모서리 둥글게 */
      box-shadow: 0 2px 4px rgba(0,0,0,0.1); /* 블록에 그림자 효과 추가 */
    }
    .one-one::before,
    .one-two::before,
    .two-one::before,
    .two-two::before {
      content: "";
      width: 30px;
      height: 30px;
      border-radius: 50%;
      background-color: red;
      border: 2px solid rgba(0,0,0,0.2); /* 원에 테두리 추가 */
      box-shadow: inset 0 0 5px rgba(0,0,0,0.2); /* 원에 내부 그림자 추가 */
    }
    .one-two::before,
    .two-one::before {
      background-color: yellow;
    }
    .two-two::before {
      background-color: green;
    }
    .one-one { width: 60px; height: 60px; }
    .one-two { width: 60px; height: 120px; }
    .two-one { width: 120px; height: 60px; }
    .two-two { width: 120px; height: 120px; }
    .hole {
      width: 60px;
      height: 60px;
      background-color: transparent;
      position: absolute;
      z-index: 0;
      border: none;
    }
    .hole::before { content: none; }
    #exit-label {
      margin-top: 5px;
      font-size: 24px;
      color: #444444;
    }
    #success {
      margin-top: 20px;
      font-size: 36px;
      color: #4CAF50;
      display: none;
    }

    .stage-button {
      font-size: 20px;
      margin: 5px;
      padding: 10px 20px;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      background-color: #ddd;
    }

    .stage-button:hover {
      background-color: #bbb;
    }

    .active {
      background-color: #3399FF;
      color: white;
    }
  </style>
</head>
<body>
  <h2>태국 탈출 퍼즐</h2>

  <div>
    <button id="btn1" class="stage-button" onclick="setStage(1)">1단계</button>
    <button id="btn2" class="stage-button" onclick="setStage(2)">2단계</button>
    <button id="btn3" class="stage-button" onclick="setStage(3)">3단계</button><br>
    <button id="btn4" class="stage-button" onclick="setStage(4)">4단계</button>
    <button id="btn5" class="stage-button" onclick="setStage(5)">5단계</button>
    <button id="btn6" class="stage-button" onclick="setStage(6)">6단계</button>
  </div>

  <br>
  <div class="move-counter">이동 횟수: <span id="moveCount">0</span></div>
  <div class="puzzle-container" id="puzzle"></div>
  <div id="exit-label">⬇ <strong>탈출구</strong></div>
  <div id="success">성공!</div>

  <div class="controls">
    <button class="stage-button" onclick="undoMove()">되돌리기</button>
    <button class="stage-button" onclick="resetPuzzle()">처음으로</button>
  </div>
  <div>
    [게임규칙]<br>
    1. 상자 안에 있는 퍼즐 조각은 위, 아래, 왼쪽, 오른쪽으로만 움직일 수 있다. <br>
    2. 퍼즐 조각 중 제일 큰 조각(녹색원)을 탈출구로 빼내면 게임은 끝난다.

  </div>

  <script>
    const puzzle = document.getElementById("puzzle");
    const moveCountEl = document.getElementById("moveCount");
    const gridCols = 4;
    const gridRows = 5;
    const cellSize = 60;

    let blocks = [];
    let moveCount = 0;
    let history = [];
    let initialBlocks = [];

    const stageData = {
      1: [
        { id: "b1", type: "two-two", x: 0, y: 2, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 0, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 1, y: 0, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 2, y: 0, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 3, y: 0, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 2, y: 4, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 3, y: 2, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 3, y: 3, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 0, y: 4, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 1, y: 4, w: 1, h: 1 }
      ],
      2: [
        { id: "b1", type: "two-two", x: 2, y: 2, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 0, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 2, y: 0, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 0, y: 2, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 1, y: 2, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 2, y: 4, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 3, y: 0, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 3, y: 1, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 0, y: 4, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 1, y: 4, w: 1, h: 1 }
      ],
      3: [
        { id: "b1", type: "two-two", x: 2, y: 0, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 3, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 1, y: 3, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 2, y: 3, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 3, y: 3, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 0, y: 0, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 0, y: 2, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 1, y: 2, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 2, y: 2, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 3, y: 2, w: 1, h: 1 }
      ],
      4: [
        { id: "b1", type: "two-two", x: 2, y: 0, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 1, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 1, y: 1, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 0, y: 3, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 1, y: 3, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 2, y: 3, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 0, y: 0, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 1, y: 0, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 2, y: 4, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 3, y: 4, w: 1, h: 1 }
      ],
      5: [
        { id: "b1", type: "two-two", x: 1, y: 0, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 3, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 1, y: 3, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 2, y: 3, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 3, y: 3, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 1, y: 2, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 0, y: 0, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 0, y: 1, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 3, y: 0, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 3, y: 1, w: 1, h: 1 }
      ],
      6: [
        { id: "b1", type: "two-two", x: 1, y: 0, w: 2, h: 2 },
        { id: "b2", type: "one-two", x: 0, y: 0, w: 1, h: 2 },
        { id: "b3", type: "one-two", x: 3, y: 0, w: 1, h: 2 },
        { id: "b4", type: "one-two", x: 0, y: 3, w: 1, h: 2 },
        { id: "b5", type: "one-two", x: 3, y: 3, w: 1, h: 2 },
        { id: "b6", type: "two-one", x: 1, y: 2, w: 2, h: 1 },
        { id: "b7", type: "one-one", x: 1, y: 3, w: 1, h: 1 },
        { id: "b8", type: "one-one", x: 2, y: 3, w: 1, h: 1 },
        { id: "b9", type: "one-one", x: 1, y: 4, w: 1, h: 1 },
        { id: "b10", type: "one-one", x: 2, y: 4, w: 1, h: 1 }
      ]
    };
    function setStage(stage) {
      document.querySelectorAll('.stage-button').forEach(btn => btn.classList.remove("active"));
      document.getElementById("btn" + stage).classList.add("active");

      initialBlocks = stageData[stage];
      resetPuzzle();
    }
    function renderBlocks() {
      puzzle.innerHTML = "";

      for (let i = 1; i <= 2; i++) {
        const hole = document.createElement("div");
        hole.className = "hole";
        hole.style.left = `${i * cellSize}px`;
        hole.style.top = `${4 * cellSize}px`;
        puzzle.appendChild(hole);
      }

      for (const block of blocks) {
        const div = document.createElement("div");
        div.className = `block ${block.type}`;
        div.style.left = `${block.x * cellSize}px`;
        div.style.top = `${block.y * cellSize}px`;
        div.style.width = `${block.w * cellSize}px`;
        div.style.height = `${block.h * cellSize}px`;
        div.setAttribute("id", block.id);
        puzzle.appendChild(div);

        let originX, originY;
        let isDragging = false;
        let currentTempX = block.x;
        let currentTempY = block.y;
        let lastValidX = block.x;
        let lastValidY = block.y;

        function handleStart(e) {
          e.preventDefault();
          isDragging = true;
          
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;
          
          originX = clientX;
          originY = clientY;
          currentTempX = block.x;
          currentTempY = block.y;
          lastValidX = block.x;
          lastValidY = block.y;
          
          div.style.transition = 'none';
          div.style.zIndex = '1000';
        }

        function handleMove(e) {
          if (!isDragging) return;
          
          const clientX = e.clientX || e.touches[0].clientX;
          const clientY = e.clientY || e.touches[0].clientY;
          
          const movedX = clientX - originX;
          const movedY = clientY - originY;

          let tempX = lastValidX;
          let tempY = lastValidY;

          if (Math.abs(movedX) > Math.abs(movedY)) {
            tempX = lastValidX + Math.round(movedX / cellSize);
          } else {
            tempY = lastValidY + Math.round(movedY / cellSize);
          }

          if (canMove(block, tempX, tempY)) {
            currentTempX = tempX;
            currentTempY = tempY;
            lastValidX = tempX;
            lastValidY = tempY;
            div.style.left = `${tempX * cellSize}px`;
            div.style.top = `${tempY * cellSize}px`;
          } else {
            div.style.left = `${lastValidX * cellSize}px`;
            div.style.top = `${lastValidY * cellSize}px`;
          }
        }

        function handleEnd(e) {
          if (!isDragging) return;
          isDragging = false;
          
          const clientX = e.clientX || e.changedTouches[0].clientX;
          const clientY = e.clientY || e.changedTouches[0].clientY;
          
          const movedX = clientX - originX;
          const movedY = clientY - originY;

          let moveX = 0;
          let moveY = 0;

          if (Math.abs(movedX) > Math.abs(movedY)) {
            moveX = Math.round(movedX / cellSize);
          } else {
            moveY = Math.round(movedY / cellSize);
          }

          // 이동 가능한 최대 거리 계산
          let finalMoveX = 0;
          let finalMoveY = 0;
          let moveSteps = 0;

          if (moveX !== 0) {
            // X축 방향으로 한 칸씩 이동 가능 여부 확인
            for (let i = 1; i <= Math.abs(moveX); i++) {
              const nextX = block.x + (moveX > 0 ? i : -i);
              if (canMove(block, nextX, block.y)) {
                finalMoveX = moveX > 0 ? i : -i;
                moveSteps++;
              } else {
                break;
              }
            }
          } else if (moveY !== 0) {
            // Y축 방향으로 한 칸씩 이동 가능 여부 확인
            for (let i = 1; i <= Math.abs(moveY); i++) {
              const nextY = block.y + (moveY > 0 ? i : -i);
              if (canMove(block, block.x, nextY)) {
                finalMoveY = moveY > 0 ? i : -i;
                moveSteps++;
              } else {
                break;
              }
            }
          }

          const newX = block.x + finalMoveX;
          const newY = block.y + finalMoveY;

          if (moveSteps > 0) {
            saveHistory();
            block.x = newX;
            block.y = newY;
            moveCount += moveSteps;
            updateMoveCount();
            checkWin();
          }

          div.style.zIndex = '';
          div.style.transition = '';
          renderBlocks();
        }

        div.addEventListener("mousedown", handleStart);
        document.addEventListener("mousemove", handleMove);
        document.addEventListener("mouseup", handleEnd);

        div.addEventListener("touchstart", handleStart);
        document.addEventListener("touchmove", handleMove);
        document.addEventListener("touchend", handleEnd);
      }
    }

    function canMove(block, newX, newY) {
      if (
        newX < 0 ||
        newY < 0 ||
        newX + block.w > gridCols ||
        newY + block.h > gridRows
      ) return false;

      // 이동 경로에 다른 블록이 있는지 확인
      const startX = Math.min(block.x, newX);
      const endX = Math.max(block.x + block.w - 1, newX + block.w - 1);
      const startY = Math.min(block.y, newY);
      const endY = Math.max(block.y + block.h - 1, newY + block.h - 1);

      for (const other of blocks) {
        if (other.id === block.id) continue;
        
        // 이동 경로상의 모든 칸을 확인
        for (let x = startX; x <= endX; x++) {
          for (let y = startY; y <= endY; y++) {
            if (
              x >= other.x && x < other.x + other.w &&
              y >= other.y && y < other.y + other.h
            ) {
              return false;
            }
          }
        }
      }
      return true;
    }

    function checkWin() {
      const target = blocks.find(b => b.type === "two-two");
      if (target.x === 1 && target.y === 3) {
        document.getElementById("success").style.display = "block";
      }
    }

    function updateMoveCount() {
      moveCountEl.textContent = moveCount;
    }

    function saveHistory() {
      history.push(JSON.parse(JSON.stringify(blocks)));
    }

    function undoMove() {
      if (history.length === 0) return;
      blocks = history.pop();
      moveCount = Math.max(0, moveCount - 1);
      updateMoveCount();
      document.getElementById("success").style.display = "none";
      renderBlocks();
    }

    function resetPuzzle() {
      blocks = JSON.parse(JSON.stringify(initialBlocks));
      history = [];
      moveCount = 0;
      updateMoveCount();
      document.getElementById("success").style.display = "none";
      renderBlocks();
    }

    // 시작 시 1단계 자동 설정
    setStage(1);
  </script>
</body>
</html>
